---
Code for Publication: "Assessing the Feasibility of Economy-Scale Direct Air Capture
  Deployment by 2050"
CodeAuthor: "Tatjana Zurbriggen (modified Code-Version of Odenweller et al. (2022))"
editor_options:
  chunk_output_type: inline
output:
  pdf_document:
    latex_engine: xelatex
---

# Setup

```{r, setup packages, warning = FALSE}
options(repos = c(CRAN = "https://cloud.r-project.org", pik = "https://rse.pik-potsdam.de/r/packages"))
install.packages("quitte")
install.packages("minpack.lm")
install.packages("openxlsx")
install.packages("parallel")
install.packages("here")
```

```{r setup, warning = FALSE}
library(tidyverse)  # Data handling
library(quitte)  # Data handling
library(readxl)  # Reading excel files
library(ggplot2)  # Plotting
library(cowplot)  # Plotting layout
library(ggnewscale)  # Multiple legends
library(ggExtra)  # Marginal distributions
library(ggsci)  # Colour palettes
library(scales)  # Plotting axes
library(zoo)  # Function na.approx
library(ggforce)  # Function facet_zoom
library(colorspace)  # Colour manipulation40
library(minpack.lm) # Modelling
library(openxlsx) #Save as Excel
library(nleqslv)  # Solving non-linear systems of equations
library(truncnorm)  # Truncated normal distribution
library(lubridate)  # Working with dates
library(dbplyr) #Data handling
library(parallel) #speed up simulation
library(data.table) #speed up simulation
library(here) #import csv files

# Input data folder
path.input <- "01_input_data_new/"
# Output folder
path.output <- "02_output_plots_new/"
# Helper functions folder
path.helpers <- "03_helpers_new/"
# Plotting functions folder
path.plotting <- "04_plotting_new/"

# Source helper functions
source(paste0(path.helpers, "ReadDACProjects.R"))
source(paste0(path.helpers, "calcTruncNormParam.R"))
source(paste0(path.helpers, "calcMonteCarloSample.R"))
source(paste0(path.helpers, "calcTechnologyDiffusion.R"))
source(paste0(path.helpers, "calcTechnologyDiffusionCapacity.R"))
source(paste0(path.helpers, "calcTechnologyDiffusionAnticipation.R"))
source(paste0(path.helpers, "calcTechnologyDiffusionLongterm.R"))
source(paste0(path.helpers, "calcTechnologyDiffusionPolicy.R"))
source(paste0(path.helpers, "calcEmergenceGrowthRate.R"))
                                                                  

# Source plotting functions
source(paste0(path.plotting, "plotDACProjects.R"))
source(paste0(path.plotting, "plotProbabilisticFeasibilitySpace.R"))
source(paste0(path.plotting, "plotProbabilisticFeasibilitySpacePolicy.R"))
source(paste0(path.plotting, "plotParameterDistributions.R"))
source(paste0(path.plotting, "plotParameterDistributionsCAP.R"))

# Mode of model execution
#model.mode <- "reproduction"
model.mode <- "simulation"

# Sample size (= monte carlo samples)
n <- 1000
# Minimum annual growth rate
bmin <- 0.00
#lower truncation, which thus constitutes the lower boundary of the CDR market ramp up

# For plotting
t.split <- 2030
t.min <- 2010
t.max <- 2050

# Set plotting style
font.size <- 10
theme_set(theme_cowplot(font_size = font.size))

# Quantile calculation. (i guess for extended data fig. 8)
quibble <- function(x, q = c(0.25, 0.33, 0.5, 0.66, 0.75)) {
  tibble(x = quantile(x, q), q = q)
}

# Regions
region.mapping.eu <- c(
  "Switzerland" = "Europe",
  "Iceland" = "Europe",
  "Norway" = "Europe",
  "Germany" = "Europe",
  "United Kingdom" = "Europe",
  "Netherlands" = "Europe",
  "Italy" = "Europe"
  
)
 region.mapping.northamerica <- c(
  "Canada" = "Canada",
  "United States" = "United States",
  "United States/Canada" = "United States/Canada"
)

region.mapping.global <- c(
  "Switzerland" = "Europe",
  "Iceland" = "Europe",
  "Norway" = "Europe",
  "Germany" = "Europe",
  "United Kingdom" = "Europe",
  "Netherlands" = "Europe",
  "Italy" = "Europe",
  "MENA" = "MENA",
  "Canada" = "North America",
  "United States" = "North America",
  "United States/Canada" = "North America",
  "South America" = "South America",
  "Australia" = "Australia",
  "Kenya" = "Kenya",
  "Unspecified" = "Unspecified",
  "Other" = "Other"
  )
```

## File Availability

```{r}
if (model.mode == "reproduction"){
  print("Model started in reproduction mode.")
  files.required <- c("02_output_plots_new/01_basecase_growth_parameters.rds",
                      "02_output_plots_new/02_basecase_growth_sample.rds",
                      "02_output_plots_new/03_basecase_growth_results.rds",
                    "02_output_plots_new/04_policycase_growth_parameters.rds",
                      "02_output_plots_new/05_policycase_growth_sample.rds",
                      "02_output_plots_new/06_policycase_growth_results.rds")
}
```

# DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

```{r, message = FALSE}
# Transformation Function (for better data discrepancy handling)
custom.trans <- function()
  trans_new(name = 'custom', 
           transform = function(x) x^0.5,  #Transformation using the square roots
            inverse = function(x) x^2) #Inverse function for axis

```

#SI_Visual_2.1: DAC Projects

```{r, message = FALSE}

regions.dac = tibble(name = c("Europe", "North America", "Global"),
  list = list(
    names(region.mapping.eu),
    names(region.mapping.northamerica),
    unique(data.dac$region)
    ))

# Europe
regions <- regions.dac$list[[1]]
names(regions) <- regions

p1 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   fill.by = "region",
                   title = "Europe: Country",
                   leg.label = "Country")

p2 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   title = "Europe: Status",
                   fill.by = "status",
                   leg.label = "Status")

# North America
regions <-  region.mapping.northamerica

p3 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   fill.by = "region",
                   title = "North America: Country",
                   leg.label = "Country")

p4 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   title = "North America: Status",
                   fill.by = "status",
                   leg.label = "Status")

# Global
regions <- region.mapping.global

p5 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   fill.by = "region",
                   title = "Global: Region",
                   leg.label = "Region")

p6 <- plotDACProjects(data.dac = data.dac,
                   regions = regions,
                   fill.by = "status",
                   title = "Global: Status",
                   leg.label = "Status")

p <- plot_grid(p1, p2, p3, p4, p5, p6,
               ncol = 2,
               labels = "auto",
               label_size = font.size)

print(p)
ggsave(paste0(path.output, "SI_VISUAL_2_DAC_Projects.png"),
       bg = "white", width = 20, height = 15, units = "cm")
ggsave(paste0(path.output, "SI_VISUAL_2_DAC_Projects.pdf"),
       bg = "white", width = 20, height = 15, units = "cm")
```


#DAC deployment targets

```{r}

# Definition minimum and maximum value 
base_case_min <- 0
base_case_max <- 5.1 * 1e3  #GtCO2 to MtCO2

# Calculation minimal values policy case
policy_case_min_aviation <- 0.5 * 0.35 * 1e3  
policy_case_min_maritime <- 0.3 * 0.35 * 1e3  
policy_case_min_chemicals <- 1.9 * 0.35 * 1e3  
policy_case_min_dac_cdr <- 2.3 * 0.35 * 1e3  

# Summarize minimal values
policy_case_min <- policy_case_min_aviation + policy_case_min_maritime 
+ policy_case_min_chemicals + policy_case_min_dac_cdr

policy_case_max <- 5.1 * 1e3 # GtCO2 to MtCO2

#Function for generating a distribution of DAC targets within a range (= block PDF)
generate_dac_target_distribution <- function(min_value, max_value, n) {
  runif(n, min = min_value, max = max_value)
}

# Creating a distribution of DAC targets for the base case
base_case_dac_targets <- generate_dac_target_distribution(base_case_min, base_case_max, n)

# Creating a distribution of DAC targets for the policy case
policy_case_dac_targets <- generate_dac_target_distribution(policy_case_min, policy_case_max, n)

# Output of the first 10 random values (for checking)
cat("Base Case DAC Targets (first 5):", base_case_dac_targets[1:10], "MtCO2\n")
cat("Policy Case DAC Targets (first 5):", policy_case_dac_targets[1:10] , "MtCO2\n")
```

#SI_Visual 3d: Global DAC Targets Distribution

```{r}
# Combine both distributions into a single data frame
combined_data <- data.frame(
  value = c(base_case_dac_targets / 1e3, policy_case_dac_targets / 1e3),
  case = rep(c("Base Case", "With Technology Policy"), 
             each = length(base_case_dac_targets))
)

# Plot both distributions in a single plot
combined_plot <- ggplot(combined_data, aes(x = value, fill = case)) +
  geom_density(alpha = 0.5) +
  ggtitle("d   Global DAC Targets Distribution") +
  xlab("DAC Capacity [GtCO2/a]") +
  ylab("Probability Density [a]") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.line.x = element_line(),        
    axis.line.y = element_blank(),       
    axis.ticks.y = element_blank(),     
    axis.text.y = element_blank(),       
    axis.ticks.x = element_blank(),   
    plot.title = element_text(hjust = 0, vjust = 1, face = "bold", size =10), 
    axis.text.x = element_text(size = 10), 
    axis.title.x = element_text(size = 10),  
    axis.title.y = element_text(size = 10),  
    legend.position = "bottom",          
    legend.text = element_text(size = 10), 
    legend.title = element_blank()        
  ) +
  scale_fill_manual(values = c("Base Case" = "#E64B3599", 
                               "With Technology Policy" = "#4DBBD599")) +
  guides(fill = guide_legend(title = "Global DAC Target Distribution"))

# Display the combined plot
print(combined_plot)

# Plot speichern als PNG und PDF
ggsave(paste0(path.output, "SI_VISUAL_3d_DAC_distribution.png"),
       width = 14, height = 10, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_VISUAL_3d_DAC_distribution.pdf"),
       width = 14, height = 10, units = "cm", bg = "white")
```

#WIND ENERGY 

## Input data

###Wind (Installed Capacity, 2024) (BP Statistical Review of World Energy 2024)

```{r}
# Read in wind data
ReadWindData <- function(file.bp) {
  data.bp.wind <-
    read_excel(
      path = file.bp,
      sheet = "Wind Installed Capacity",
      range = "A4:AB70",
      col_names = TRUE
    ) %>%
    filter(Megawatts == "Total World") %>%
    pivot_longer(cols = `1997`:`2023`,
                 names_to = "year",
                 values_to = "capacity") %>%
    mutate(region = "Global",
           technology = "Wind",
          year = as.numeric(year),
           unit = "MW",
           tech = "Global Wind Power") %>%
    rename(value = capacity) %>%
    select(year, value, region, technology, unit, tech) %>%
    arrange(year)
  
  return(data.bp.wind)
}

# Path to the BP Statistical Review of World Energy 2024
file.bp <- paste0(path.input, "EI-Stats-Review-All-Data.xlsx")
data.wind.global <- ReadWindData(file.bp) %>%
mutate(number = 1)
```


```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.wind.global
)

# Adjust data type
data.technologies <- data.technologies %>%
  mutate(year = as.numeric(year),
         value = as.numeric(value))

```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))

print(data.technologies.fit %>% select(technology, region, b))
```


## Monte Carlo sampling: Initial capacity, emergence growth rate

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "Wind"
    
    )
 data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/01_WIND_ENERGY_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/02_WIND_ENERGY_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/01_WIND_ENERGY_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/02_WIND_ENERGY_growth_sample.rds")
}

```


#SI_Visual_2.2: Initial Capacity Dsitribution 
```{r, message = FALSE}

#Fixed colors and levels for status (uniform for all plots)
status_cols <- c(
  "Planned/Announced"            = "#4D7DBF",  # dunkelblau
  "Feasibility Study"            = "#3395AB",
  "Design and Engineering Phase" = "#818F42",
  "FID"                          = "orange",
  "Under Construction"           = "pink",
  "Operational"                  = "magenta",
  "Decommissioned"               = "#8C8C8C"
)
status_levels <- names(status_cols)

## X-Limits per region (for start values)
x.limits <- list(
  "Europe"        = c(0, 8),
  "North America" = c(0, 8),
  "Global"        = c(0, 15)
)

plots <- plotParameterDistributionsCAP(data.input, data.input.param)

p.col1 <- plot_grid(
  plots[[1]] + theme(legend.position = "none"),
  plots[[2]] + theme(legend.position = "none"),
  NULL,
  ncol = 1, align = "v",
  rel_heights = c(1, 0.15),
  labels = c("a", ""), label_size = font.size
)

p.col2 <- plot_grid(
  plots[[3]] + theme(legend.position = "none"),
  plots[[4]] + theme(legend.position = "none"),
  NULL,
  ncol = 1, align = "v",
  rel_heights = c(1, 0.15),
  labels = c("b", ""), label_size = font.size
)

p.col3 <- plot_grid(
  plots[[5]] + theme(legend.position = "none"),
  plots[[6]] + theme(legend.position = "none"),
  NULL,
  ncol = 1, align = "v",
  rel_heights = c(1, 0.15),
  labels = c("c", ""), label_size = font.size
)

p.plots  <- plot_grid(p.col1, p.col2, p.col3, nrow = 1)
p.legend <- plot_grid(
  NULL,
  get_legend(plots[[2]] + theme(legend.position = "bottom")),
  NULL, nrow = 1, rel_widths = c(1, 0.8, 1)
)

p <- plot_grid(p.plots, p.legend, ncol = 1, rel_heights = c(1, 0.15))

print(p)

ggsave(paste0(path.output, "SI_Visual_2.2_Initial_Capacity_Dsitribution.png"),
       width = 20, height = 17, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_Visual_2.2_Initial_Capacity_Dsitribution.pdf"),
       width = 20, height = 17, units = "cm", bg = "white")

```


#SI_Visual 3b: Global Wind Growth (Parameter Distribution)
```{r, message = FALSE}
plots <- plotParameterDistributions(data.input = data.input,
                                    data.input.param = data.input.param,
                                    tech_to_plot = "Wind")

# Extract only growth plots
growth_plots <- plots[c(seq(1, length(plots), by = 1))]  

# Generate the final plot layout
p.col3 <- plot_grid(growth_plots[[1]] + theme(legend.position = "none"),
                    ncol = 1,
                    labels = c("b"),
                    label_size = font.size)

# Combine plots
p.plots <- plot_grid(p.col3, nrow = 1)

# Extract legend
p.legend <- plot_grid(NULL, get_legend(plots[[1]] + 
                                         theme(legend.position = "bottom")
                                       ), nrow = 1)

# Final plot layout
p <- plot_grid(p.plots, p.legend, ncol = 1, rel_heights = c(1, 0.15))

# Show the plot
print(p)

# Save plot for Wind
ggsave(paste0(path.output, "SI_VISUAL_3b_parameter_distributions_year2030_WIND.png"),
       width = 14, height = 9, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_VISUAL_3b_parameter_distributions_year2030_WIND.pdf"),
       width = 14, height = 9, units = "cm", bg = "white")

```



# A) Base case (without enhanced technology policy)

## Demand pull 
```{r}

# Define anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  

data.results.wind.base <- data.results
  
# Save simulation results
  saveRDS(data.results.wind.base,
          "02_output_plots_new/01_WIND_ENERGY_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.wind.base <-
    readRDS("02_output_plots_new/01_WIND_ENERGY_BASE_CASE_results.rds")
}
```


# B) Enhanced Policy Case


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "Wind"
    
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/03_WIND_ENERGY_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/04_WIND_ENERGY_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/03_WIND_ENERGY_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/04_WIND_ENERGY_POLICY_CASE_growth_sample.rds")
}
```


## Demand pull 
```{r}
# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)

```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
  
  data.results.wind.policy <- data.results
  
  # Save simulation results
  saveRDS(data.results.wind.policy,
          "02_output_plots_new/01_WIND_ENERGY_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.policy <-
    readRDS("02_output_plots_new/01_WIND_ENERGY_BASE_CASE_results.rds")
}
```


```{r}
# Extract data from data.results.policy and convert it into a DataFrame
data_to_save_wind <- data.results.wind.policy %>%
  filter(region %in% c("Global"), anticipation == 15) %>%  
  unnest(sensitivities) %>%  
  select(-demand) %>%  
  unnest(results) %>% 
  select(region, anticipation, year, forecast)  

# Save CSV data
write.csv(data_to_save_wind, 
          paste0(path.output,
"SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind.csv"), 
          row.names = FALSE)
cat("The data has been successfully saved to the CSV file.")
```

#LIQUID NATRUAL GAS (LNG)

## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

##Input data 

### Global Liquid Natural Gas (Capacity) (Greene, J., Nemet, G., Hammersmith, A. & Zaiser, A. The Historical Adoption of TeCHnology (HATCH) Dataset. (2023).)

```{r}
data.naturalgas <- tibble(
 
#DATA HATCH DATABASE: Global Liquefied Natural Gas Plants (millon tons per year)
year = c(#1970, 1972, 1973, 
         1974, 1977, 1978,1981, 1983,1989,1992,1993, 1994, 1995, 1996, 1997, 
         1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 
         2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020),

 production = c(#3.2, 6.08, 8.96, 
                10.4, 11.84, 13.28, 14.72, 16.16, 17.6, 19.02, 20.48, 21.92, 
                23.36,	24.8,	26.24,	27.68,	29.12,	30.56, 32,	33.44,	
                34.88,	36.32, 37.76,	39.2,	40.64, 42.08,	43.52, 44.96, 
                46.4, 47.84, 49.28, 50.72, 52.16,	53.6,	55.04,	56.48,	57.92)
) %>% 
  mutate(value = production,
         region = "Global",
         technology = "LNG",
         #unit = "MW",
         unit = "million tons/yr",
         tech = "Global Liquid Natural Gas",
         number = 4) %>%
         select(year, value, region, technology, unit, tech, number) %>%
         arrange(year)
```


```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.naturalgas
)

# Adjust data type
data.technologies <- data.technologies %>%
  mutate(year = as.numeric(year),
         value = as.numeric(value))

```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))
print(data.technologies.fit %>% select(technology, region, b))
```

## Monte Carlo sampling: Initial capacity, emergence growth rate

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "LNG"
    )
data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/05_LNG_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/06_LNG_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/05_LNG_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/06_LNG_growth_sample.rds")
}
```


#SI_Visual 3c: Global Ammonia Synthesis (Parameter Distribution)
```{r, message = FALSE}
plots <- plotParameterDistributions(data.input = data.input,
                                    data.input.param = data.input.param,
                                    tech_to_plot = "LNG")  

# Extract only growth plots
growth_plots <- plots[c(seq(1, length(plots), by = 1))]  

# Generate the final plot layout
p.col3 <- plot_grid(growth_plots[[1]] + theme(legend.position = "none"),
                    ncol = 1,
                    labels = c("b"),
                    label_size = font.size)

# Combine plots
p.plots <- plot_grid(p.col3, nrow = 1)

# Extract legend
p.legend <- plot_grid(NULL, 
                      get_legend(plots[[1]] 
                                 + theme(legend.position = "bottom")), nrow = 1)

# Final plot layout
p <- plot_grid(p.plots, p.legend, ncol = 1, rel_heights = c(1, 0.15))

# Show the plot
print(p)

# Save plot for Wind
ggsave(paste0
       (path.output,"SI_VISUAL_3c_parameter_distributions_year2030_LNG.png"),
       width = 14, height = 9, units = "cm", bg = "white")
ggsave(paste0
       (path.output, "SI_VISUAL_3c_parameter_distributions_year2030_LNG.pdf"),
       width = 14, height = 9, units = "cm", bg = "white")
```
# A) Base case (without enhanced technology policy)

## Demand pull 
```{r}

# Define anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  
data.results.naturalgas.base <- data.results

  # Save simulation results
  saveRDS(data.results.naturalgas.base,
          "02_output_plots_new/02_LNG_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.naturalgas.base <-
    readRDS("02_output_plots_new/02_LNG_BASE_CASE_results.rds")
}
```

# B) Enhanced Policy Case


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "LNG" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/07_LNG_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/08_LNG_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/07_LNG_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/08_LNG_POLICY_CASE_growth_sample.rds")
}
```


## Demand pull 
```{r}
# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.policy <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
  
  data.results.naturalgas.policy <-  data.results.policy
  
  # Save simulation results
  saveRDS(data.results.naturalgas.policy,
          "02_output_plots_new/03_conventional_growth_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.naturalgas.policy <-
    readRDS("02_output_plots_new/03_conventional_growth_results.rds")
}
```


```{r}
# Extract data from data.results.policy and convert it into a DataFrame
data_to_save_LNG <- data.results.naturalgas.policy %>%
  filter(region %in% c("Global"), anticipation == 15) %>%  
  unnest(sensitivities) %>%  
  select(-demand) %>%  
  unnest(results) %>% 
  select(region, anticipation, year, forecast)  

# Save CSV data
write.csv(data_to_save_LNG, paste0(path.output, "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG.csv"), 
          row.names = FALSE)
cat("The data has been successfully saved to the CSV file.")
```

#AMMONIA SYNTHESIS

## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

## Input data

### Global Ammonia Synthesis Production (Global Annual Production) (Roberts and Nemet, 2024)

```{r}
#Commented out values which do not represent the exponential growth of this technology
data.ammonia <- tibble(
  year = c(#1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 
    1932, 1933, 1934, 1935, 1936, 1937, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 
    1955, 1956, 1957, 1958, 1959
           #, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 
    #1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 
    #1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 
    #1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 
    #2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
  ),
  production = c(#367, 485, 442.1, 439.1, 522.2, 560, 534.7, 533, 
    630, 654, 1061, 3589.987, 3956.773, 4462.385,13544.151, 15477.434, 17609.862, 
    20325.168, 23070.228, 25836.183, 28141.97, 30195.308, 33258.266, 35249.174, 
    38350.337, 41033.282 #, 42414.805, 44619.593, 46449.524, 50468.029, 55909.463, 
    #59622.703, 62777.606, 62291.849, 63493.886, 68268.923, 74855.695, 73680.818, 
    #77696.274, 82028.36, 85767.301, 85185.849, 82279.841, 80831.186, 80314.695, 
    #80302.72,80011.675, 86486.98, 90418.464, 87566.043, 88392.236, 89161.871, 
    #85129.097,85670.741, 87334.65659, 88722.23565, 94211.27627, 95401.6224, 
    #95157.92192, 102402.8279, 100266.5045, 98588.04969, 107431.9324, 107783.99, 
    #109821.5327, 114908.875, 115823.0681, 120785.4006, 119405.796, 120677.587, 
    #121230.526, 123987.3633, 123145.0518, 98588.04969, 107431.9324, 107783.99, 
    #109821.5327, 114908.875, 115823.0681, 120785.4006, 119405.796, 120677.587, 
    #121230.526, 123987.3633, 123145.0518
 )
) %>%
  mutate(value = production,
         region = "Global",
         technology = "Ammonia Synthesis",
         unit = "Tons per year",
         tech = "Global Annual Ammonia Synthesis Production",
         number = 5) %>%
         select(year, value, region, technology, unit, tech, number) %>%
         arrange(year)
```


```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.ammonia
)

# Adjust data type
data.technologies <- data.technologies %>%
mutate(year = as.numeric(year),
         value = as.numeric(value))

```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))

print(data.technologies.fit %>% select(technology, region, b))
```

## Monte Carlo sampling: Initial capacity, emergence growth rate

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "Ammonia Synthesis" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/09_AMMONIA_SYNTHESIS_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/10_AMMONIA_SYNTHESIS_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/09_AMMONIA_SYNTHESIS_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/10_AMMONIA_SYNTHESIS_growth_sample.rds")
}
```

#SI_Visual 3a: Global Ammonia Synthesis (Parameter Distribution)
```{r, message = FALSE}
plots <- plotParameterDistributions(data.input = data.input,
                                    data.input.param = data.input.param,
                                    tech_to_plot = "Ammonia Synthesis")  

# Extract only growth plots
growth_plots <- plots[c(seq(1, length(plots), by = 1))]  

# Generate the final plot layout
p.col3 <- plot_grid(growth_plots[[1]] + theme(legend.position = "none"),
                    ncol = 1,
                    labels = c("b"),
                    label_size = font.size)

# Combine plots
p.plots <- plot_grid(p.col3, nrow = 1)

# Extract legend
p.legend <- plot_grid(NULL, get_legend(plots[[1]] + theme(legend.position = "bottom")), 
                      nrow = 1)

# Final plot layout
p <- plot_grid(p.plots, p.legend, ncol = 1, rel_heights = c(1, 0.15))

# Show the plot
print(p)

# Save plot for Wind
ggsave(paste0(path.output, "SI_VISUAL_3a_parameter_distributions_year2030_AMMONIA_SYNTHESIS.png"),
       width = 14, height = 9, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_VISUAL_3a_parameter_distributions_year2030_AMMONIA_SYNTHESIS.pdf"),
       width = 14, height = 9, units = "cm", bg = "white")
```

# A) Base case (without enhanced technology policy)

## Demand pull 
```{r}

# Define anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  
data.results.ammonia.base <- data.results

  # Save simulation results
  saveRDS(data.results.ammonia.base,
          "02_output_plots_new/03_AMMONIA_SYNTHESIS_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.ammonia.base <-
    readRDS("02_output_plots_new/03_AMMONIA_SYNTHESIS_BASE_CASE_results.rds")
}
```

# C, i) Individual technology policy levers (i) policy push fostering short-term DAC capacity (capacity.factor = 10)) 

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "Ammonia Synthesis" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/11_AMMONIA_SYNTHESIS_CI_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/12_AMMONIA_SYNTHESIS_CI_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/11_AMMONIA_SYNTHESIS_CI_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/12_AMMONIA_SYNTHESIS_CI_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
    demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.capacity <-
    calcTechnologyDiffusionCapacity(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.capacity,
          "02_output_plots_new/04_AMMONIA_SYNTHESIS_CI_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.capacity <-
    readRDS("02_output_plots_new/04_AMMONIA_SYNTHESIS_CI_results.rds")
}
```


# C, ii) Individual technology policy levers (ii) creating credibility in long-term DAC requirements (anticipation))

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "Ammonia Synthesis"
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/13_AMMONIA_SYNTHESIS_CII_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/14_AMMONIA_SYNTHESIS_CII_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/13_AMMONIA_SYNTHESIS_CII_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/14_AMMONIA_SYNTHESIS_CII_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.anticipation <-
    calcTechnologyDiffusionAnticipation(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.anticipation,
          "02_output_plots_new/05_AMMONIA_SYNTHESIS_CII_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.anticipation <-
    readRDS("02_output_plots_new/05_AMMONIA_SYNTHESIS_CII_results.rds")
}
```

# B) Enhanced Policy Case


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "Ammonia Synthesis" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/15_AMMONIA_SYNTHESIS_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/16_AMMONIA_SYNTHESIS_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/15_AMMONIA_SYNTHESIS_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/16_AMMONIA_SYNTHESIS_POLICY_CASE_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.policy <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
 
   data.results.ammonia.policy <- data.results.policy
   
   # Save simulation results
  saveRDS(data.results.ammonia.policy,
          "02_output_plots_new/06_AMMONIA_SYNTHESIS_POLICY_CASE_results.rds")
  
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.ammonia.policy <-
    readRDS("02_output_plots_new/06_AMMONIA_SYNTHESIS_POLICY_CASE_results.rds")
}
```
# C, iii) Individual technology policy levers (iii) Long-term Market Growth)


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,

    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "Ammonia Synthesis"
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/17_AMMONIA_SYNTHESIS_CIII_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/18_AMMONIA_SYNTHESIS_CIII_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/17_AMMONIA_SYNTHESIS_CIII_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/18_AMMONIA_SYNTHESIS_CIII_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- 
  combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(
  demand, n = anticipation, type = "lead", fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(
  demand = list(data.frame(year = year, demand = demand))), 
  by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)

```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.longterm <-
    calcTechnologyDiffusionLongterm(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.longterm,
          "02_output_plots_new/07_AMMONIA_SYNTHESIS_CIII_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.longterm <-
    readRDS("02_output_plots_new/07_AMMONIA_SYNTHESIS_CIII_results.rds")
}
```


#VISUAL 1.1: A) Base case versus B) enhanced policy case and C) the individual policy levers 

```{r}
# Colours out of pal_npg-Palette
colours <- pal_npg("nrc")(10) 

# Loading CSV data
LNG_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG.csv"))
wind_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind.csv"))

# Calculating the median of LNG data
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Calculating the median of wind energy data
wind_data_stat <- wind_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Function for creating plots with consistent coloring
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour_index,
                                              title,
                                              dac_target_base,
                                              ci.80 = F,  # 80% Confidence interval
                                              slices = 500,
                                              random.paths = 10,
                                              zoom.panel = F) { 
  
  # Prepare data
  data.plot <- data.row %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results)

  
  # Select base color for the plot
  base_color <- colours[colour_index]
  if (title == "Base case  Wind") {
  base_color <- "#66AFC0"
}
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  }
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }

  # Group the data and calculate quantiles for each year
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))

  # Get demand curves for all DAC destinations
  data.plot.demand <- data.row %>%
    unnest(demand) %>%
    select(year, demand #, dac_target_base
           ) %>%  
    group_by(year) %>%
    summarise(demand_mean = mean(demand), .groups = 'drop')
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate the density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(data.plot.demand$demand_mean, na.rm = T)
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }

  # Create the plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", 
                        low = "white", high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2050, by = 5)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1250),
    breaks = seq(0, 1250, by = 250)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )
 
 
   # Optional zoom panel
   if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, t.max),
        ylim = c(0, max(data.plot.demand$demand_mean)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
    p.plot <- p.facet 
  
  return(p.plot)
}

# Adaptation of the plotProbabilisticFeasibilitySpace_with_base_median function
plotProbabilisticFeasibilitySpace_with_base_median <- function(data.row,
                                                              dac_target_base,
                                                              dac_target_policy,
                                                              colour_index,
                                                              plot.marginal = T,
                                                              marginal.year,
                                                              title,
                                                              ci.80 = F,
                                                              slices = 500,
                                                              random.paths = 10,
                                                              base_case_median,  
                                                              show_LNG_wind_medians = TRUE, 
                                                              LNG_data_stat = NULL,  
                                                              wind_data_stat = NULL, 
                                                              text_offset = 0.1, 
                                                              text_offset_LNG = -0.1, 
                                                              text_offset_wind = 0.2,
                                                              zoom.panel = F,
                                                              round_to_tens = TRUE) { 
  
   # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)

  # Select base color for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3), 
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  
                   "0.5" = darken(base_color, 0.3),  
                   "0.05" = base_color)  
  }
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%  
    mutate(q = as.factor(q))

  
  # Receive demand (korrekt aus data.row)
 data.plot.demand <- data.row %>%
   unnest(demand) %>%
   select(year, demand) %>%
   group_by(year) %>%
   summarise(demand_mean = mean(demand), .groups = "drop")
 
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate the density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(data.plot.demand$demand_mean, na.rm = TRUE)
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Create the plot
  p.facet <- ggplot() +
    geom_raster(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density),
      interpolate = TRUE
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", 
                        low = "white", high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    # Median A) Base Case hinzufgen
    geom_line(
      data = base_case_median,
      aes(x = year, y = x),
      linetype = "dotted",  
      color = "#E64B35FF",  
      size = 0.8  
    ) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2050, by = 5)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
    plot.title = element_text(face = "bold", size = font.size)
  )
  
  # Show LNG/Wind medians only if activated
  if (show_LNG_wind_medians) {
    # Add LNG median 
    p.facet <- p.facet + 
      geom_line(
        data = LNG_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "#00A087FF",  
        size = 0.8
      )
    # Add wind energy median 
    p.facet <- p.facet + 
      geom_line(
        data = wind_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "blue",  
        size = 0.8
      )
  }
  
  # Optional zoom panel
  if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, 2030),
        ylim = c(0, data.plot.targets %>% filter(year == 2030) %>% pull(value)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
  
  p.plot <- p.facet 
  
  # Calculation of the percentage deviation between median of the base case and 
  #the median of the current curve
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- data.stat %>% filter(q == 0.5, year == marginal.year) %>% pull(x)
  percentage_difference <- ((current_median_value - base_median_value) 
                            / base_median_value) * 100

  # Apply rounding to 10s or 1s depending on the parameter
  round_digits <- ifelse(round_to_tens, -1, 0)

  # Add text to display the percentage deviation
p.plot <- p.plot +
  annotate("text", x = max(data.stat$year) + 1, 
           y = min(current_median_value + text_offset * current_median_value, 2000), 
           label = paste0("~ ", format(round(percentage_difference, round_digits), 
                                       nsmall = 0), " % "),# Dynamische Rundung
           hjust = 1, size = 3, color = "#E64B35FF")

# Calculation and annotation for LNG median deviation
if (show_LNG_wind_medians && !is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == marginal.year) %>% pull(x)
  LNG_percentage_difference <- 
    ((LNG_median_value - base_median_value) / base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 2100), 
             label = paste0("~ ", format(round(LNG_percentage_difference, round_digits), 
                     nsmall = 0), " %  LNG"),  # Dynamische Rundung
             hjust = 1, size = 3, color = "#00A087FF")
}

# Calculation and annotation for wind energy median deviation
if (show_LNG_wind_medians && !is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == marginal.year) %>% pull(x)
  wind_percentage_difference <- 
    ((wind_median_value - base_median_value) / base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 2200), 
             label = paste0("~ ", format(round(wind_percentage_difference, round_digits), 
                     nsmall = 0), " %  Wind"),  # Dynamische Rundung
             hjust = 1, size = 3, color = "blue")
}
  
  # Legend for all lines
  if (show_LNG_wind_medians) {
    p.plot <- p.plot +
      scale_color_manual(
        values = c(
          "Base case median" = "#E64B35FF",  
          "LNG median" = "#00A087FF",           
          "Wind median" = "blue"             
        ),
        labels = c(
          "Base case median" = "Base case median",
          "LNG median" = "LNG median",
          "Wind median" = "Wind median"
        ),
        name = "Medians"
      ) +
      guides(
        color = guide_legend(
          override.aes = list(
            linetype = c("dotted", "dashed", "dashed"), 
            color = c("#E64B35FF", "#00A087FF", "blue") 
          ),
          order = 5
        )
      )
  }
  
  return(p.plot)
}

# A) Base case

p_base_case_ammonia <- plotProbabilisticFeasibilitySpace(
  data.row = data.results.ammonia.base %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 5,
  title = "Base case  Ammonia Synthesis")

p_base_case_naturalgas <- plotProbabilisticFeasibilitySpace(
  data.row = data.results.naturalgas.base %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 3,
  title = "Base case  LNG")

p_base_case_wind <- plotProbabilisticFeasibilitySpace(
  data.row = data.results.wind.base %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 2,   # dieser Wert wird zwar bergeben
  title = "Base case  Wind"
) + scale_fill_gradient(low = "white", high = "#66AFC0") +
    scale_color_manual(values = c("0.95" = lighten("#66AFC0", 0.3),
                                  "0.5" = darken("#66AFC0", 0.3),
                                  "0.05" = "#66AFC0"),
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.5" = "50 % (Median)",
                                  "0.05" = "5 %"))


# Median of the base case
base_case_median <- data.results.ammonia.base %>%
  filter(region == "Global", anticipation == 5) %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results) %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  # Calculate median (50% quantile)

base_case_median <- as.data.frame(base_case_median)

# B) Enhanced policy case
p_policy_case_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.ammonia.policy %>% 
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 2,
  marginal.year = 2045,
  title = "Enhanced policy case",
  base_case_median = base_case_median,
  show_LNG_wind_medians = TRUE,  # Show LNG/Wind median
  LNG_data_stat = LNG_data_stat,  # LNG median data
  wind_data_stat = wind_data_stat,  # Wind median data
  text_offset = 30, 
  text_offset_LNG = 0.7, 
  text_offset_wind = 0.9 
  ) + 
  scale_y_continuous(                                           
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 3300),
    breaks = seq(0, 3300, by = 250)
  )

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 10
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>%
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 30,
  round_to_tens = FALSE  
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 30,
  round_to_tens = FALSE  
)


# Adjustment of the y-axis

# A) Global Base Case
p_base_case <- p_base_case_ammonia + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1250),
    breaks = seq(0, 1250, by = 250) 
  )

p_base_case <- p_base_case_naturalgas + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1250),
    breaks = seq(0, 1250, by = 250)  
  )

p_base_case <- p_base_case_wind + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1250),
    breaks = seq(0, 1250, by = 250)  
  )

# B) Global Policy Case
p_policy_case_with_median <- p_policy_case_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1250),
    breaks = seq(0, 1250, by = 250)  
  )


# i) Policy Push: Short-term Capacity
p_policy_push_with_median <- p_policy_push_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# ii) Demand Pull: Anticipation
p_demand_pull_anticipation_with_median <- p_demand_pull_anticipation_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# iii) Demand Pull: Long-term Market Growth
p_demand_pull_ltm_with_median <- p_demand_pull_ltm_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# Merging the plots into the layout

# A) first row: A-i and A-ii
A_row_top <- plot_grid(
  p_base_case_ammonia, p_base_case_naturalgas,
  ncol = 2,
  labels = c("A-i", "A-ii"),
  label_size = 10
)

# A) + B) second row: A-iii and B
A_row_bottom <- plot_grid(
  p_base_case_wind, p_policy_case_with_median,
  ncol = 2,
  labels = c("A-iii", "B"),
  label_size = 10
)

# Combine upper and lower line
upper_plot <- plot_grid(
  A_row_top,
  A_row_bottom,
  ncol = 1,
  rel_heights = c(1, 1)
)

# Title
title <- ggdraw() + 
  draw_label(
    "Global DAC Capacity in 2050",
    fontface = 'bold',
    size = 12,
    hjust = 0.5,
    vjust = 0.1
  )

# Final Plot
final_plot <- plot_grid(
  title,
  upper_plot,
  ncol = 1,
  rel_heights = c(0.1, 2)
)

print(final_plot)

# Save
ggsave(paste0(path.output, "VISUAL_1.1_Probabilistic_Feasibility_Space_AMMONIA.png"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
ggsave(paste0(path.output, "VISUAL_1.1_Probabilistic_Feasibility_Space_AMMONIA.pdf"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
```

#VISUAL 1.2: C) individual policy levers 

```{r}
colours <- pal_npg("nrc")(10) 

# Loading CSV data
LNG_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG.csv"))
wind_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind.csv"))

# Calculating the median of LNG data
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Calculating the median of wind energy data
wind_data_stat <- wind_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Function for creating plots with consistent coloring
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour_index,
                                              title,
                                              dac_target_base,
                                              ci.80 = F,  # 80% Confidence interval
                                              slices = 500,
                                              random.paths = 10,
                                              zoom.panel = F) { 
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Select base color for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  }
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }

  # Group the data and calculate quantiles for each year
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))

  # Get demand curves for all DAC destinations
  data.plot.demand <- data.row %>%
    unnest(demand) %>%
    select(year, demand, dac_target_base) %>%  
    group_by(year) %>%
    summarise(demand_mean = mean(demand), .groups = 'drop')
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate the density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(data.plot.demand$demand_mean, na.rm = T)
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }

  # Create the plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", 
                        low = "white", high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2050, by = 5)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )
 
 
   # Optional zoom panel
   if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, t.max),
        ylim = c(0, max(data.plot.demand$demand_mean)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
    p.plot <- p.facet 
  
  return(p.plot)
}

# Adaptation of the plotProbabilisticFeasibilitySpace_with_base_median function
plotProbabilisticFeasibilitySpace_with_base_median <- function(data.row,
                                                              dac_target_base,
                                                              dac_target_policy,
                                                              colour_index,
                                                              plot.marginal = T,
                                                              marginal.year,
                                                              title,
                                                              ci.80 = F,
                                                              slices = 500,
                                                              random.paths = 10,
                                                              base_case_median,  
                                                              show_LNG_wind_medians = TRUE, 
                                                              LNG_data_stat = NULL,  
                                                              wind_data_stat = NULL, 
                                                              text_offset = 0.1, 
                                                              text_offset_LNG = -0.1, 
                                                              text_offset_wind = 0.2,
                                                              zoom.panel = F,
                                                              round_to_tens = TRUE) { 
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)

  # Select base color for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3), 
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  
                   "0.5" = darken(base_color, 0.3),  
                   "0.05" = base_color)  
  }
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%  
    mutate(q = as.factor(q))
  
  # Receive demand
  #data.plot.demand <- data.plot %>%
  #  filter(sample == 1)
  
  
  # Receive demand (korrekt aus data.row)
 data.plot.demand <- data.row %>%
   unnest(demand) %>%
   select(year, demand) %>%
   group_by(year) %>%
   summarise(demand_mean = mean(demand), .groups = "drop")
 
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate the density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(data.plot.demand$demand_mean, na.rm = TRUE)
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Create the plot
  p.facet <- ggplot() +
    geom_raster(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density),
      interpolate = TRUE
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", 
                        low = "white", high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    # Median A) Base Case hinzufgen
    geom_line(
      data = base_case_median,
      aes(x = year, y = x),
      linetype = "dotted",  
      color = "#E64B35FF",  
      size = 0.8  
    ) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2050, by = 5)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
    plot.title = element_text(face = "bold", size = font.size)
  )
  
  # Show LNG/Wind medians only if activated
  if (show_LNG_wind_medians) {
    # Add LNG median 
    p.facet <- p.facet + 
      geom_line(
        data = LNG_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "#00A087FF",  
        size = 0.8
      )
    # Add wind energy median 
    p.facet <- p.facet + 
      geom_line(
        data = wind_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "blue",  
        size = 0.8
      )
  }
  
  # Optional zoom panel
  if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, 2030),
        ylim = c(0, data.plot.targets %>% filter(year == 2030) %>% pull(value)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
  
  p.plot <- p.facet 
  
  # Calculation of the percentage deviation between median of the base case and 
  #the median of the current curve
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- data.stat %>% filter(q == 0.5, year == marginal.year) %>% pull(x)
  percentage_difference <- ((current_median_value - base_median_value) 
                            / base_median_value) * 100

  # Apply rounding to 10s or 1s depending on the parameter
  round_digits <- ifelse(round_to_tens, -1, 0)

  # Add text to display the percentage deviation
p.plot <- p.plot +
  annotate("text", x = max(data.stat$year) + 1, 
           y = min(current_median_value + text_offset * current_median_value, 2000), 
           label = paste0("~ ", format(round(percentage_difference, round_digits), 
                                       nsmall = 0), " % "),# Dynamische Rundung
           hjust = 1, size = 3, color = "#E64B35FF")

# Calculation and annotation for LNG median deviation
if (show_LNG_wind_medians && !is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == marginal.year) %>% pull(x)
  LNG_percentage_difference <- 
    ((LNG_median_value - base_median_value) / base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 2100), 
             label = paste0("~ ", format(round(LNG_percentage_difference, round_digits), 
                     nsmall = 0), " %  LNG"),  # Dynamische Rundung
             hjust = 1, size = 3, color = "#00A087FF")
}

# Calculation and annotation for wind energy median deviation
if (show_LNG_wind_medians && !is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == marginal.year) %>% pull(x)
  wind_percentage_difference <- 
    ((wind_median_value - base_median_value) / base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 2200), 
             label = paste0("~ ", format(round(wind_percentage_difference, round_digits), 
                     nsmall = 0), " %  Wind"),  # Dynamische Rundung
             hjust = 1, size = 3, color = "blue")
}
  
  # Legend for all lines
  if (show_LNG_wind_medians) {
    p.plot <- p.plot +
      scale_color_manual(
        values = c(
          "Base case median" = "#E64B35FF",  
          "LNG median" = "#00A087FF",           
          "Wind median" = "blue"             
        ),
        labels = c(
          "Base case median" = "Base case median",
          "LNG median" = "LNG median",
          "Wind median" = "Wind median"
        ),
        name = "Medians"
      ) +
      guides(
        color = guide_legend(
          override.aes = list(
            linetype = c("dotted", "dashed", "dashed"), 
            color = c("#E64B35FF", "#00A087FF", "blue") 
          ),
          order = 5
        )
      )
  }
  
  return(p.plot)
}

# A) Base case
p_base_case <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 5,
  title = "Base case"
)

# Median of the base case
base_case_median <- data.results %>%
  filter(region == "Global", anticipation == 5) %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results) %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  # Calculate median (50% quantile)

base_case_median <- as.data.frame(base_case_median)

# B) Enhanced policy case
p_policy_case_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.policy %>%
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 2,
  marginal.year = 2045,
  title = "Enhanced policy case",
  base_case_median = base_case_median,
  show_LNG_wind_medians = TRUE,  # Show LNG/Wind median
  LNG_data_stat = LNG_data_stat,  # LNG median data
  wind_data_stat = wind_data_stat,  # Wind median data
  text_offset = 30, 
  text_offset_LNG = 0.7, 
  text_offset_wind = 0.9 
)

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 10
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>%
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 30,
  round_to_tens = FALSE  
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 30,
  round_to_tens = FALSE  
)


# Adjustment of the y-axis

# A) Global Base Case
p_base_case <- p_base_case + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# B) Global Policy Case
p_policy_case_with_median <- p_policy_case_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )


# i) Policy Push: Short-term Capacity
p_policy_push_with_median <- p_policy_push_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# ii) Demand Pull: Anticipation
p_demand_pull_anticipation_with_median <- p_demand_pull_anticipation_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# iii) Demand Pull: Long-term Market Growth
p_demand_pull_ltm_with_median <- p_demand_pull_ltm_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 1800),
    breaks = seq(0, 1800, by = 250) 
  )

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>% filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,
  text_offset = 10
) + scale_y_continuous(
  labels = scales::label_number(scale = 1e-3),
  expand = expansion(mult = c(0.01, 0.05)),
  limits = c(0, 1800),
  breaks = seq(0, 1800, by = 250)
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>% filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,
  text_offset = 30,
  round_to_tens = FALSE
) + scale_y_continuous(
  labels = scales::label_number(scale = 1e-3),
  expand = expansion(mult = c(0.01, 0.05)),
  limits = c(0, 1800),
  breaks = seq(0, 1800, by = 250)
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>% filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,
  text_offset = 30,
  round_to_tens = FALSE
) + scale_y_continuous(
  labels = scales::label_number(scale = 1e-3),
  expand = expansion(mult = c(0.01, 0.05)),
  limits = c(0, 1800),
  breaks = seq(0, 1800, by = 250)
)

# Title for C)
title_lower_plots <- ggdraw() +
  draw_label(
    "C        Policy levers",
    fontface = 'bold', size = 10,
    hjust = 0, x = 0, y = 0.7
  )

# Subplots (iiii)
lower_plot <- plot_grid(
  p_policy_push_with_median,
  p_demand_pull_anticipation_with_median,
  p_demand_pull_ltm_with_median,
  ncol = 3, nrow = 1,
  labels = c("i", "ii", "iii"),
  label_size = 10
)

# Final: only C) plot
final_plot_C <- plot_grid(
  title_lower_plots,
  lower_plot,
  ncol = 1, rel_heights = c(0.15, 1)
)

print(final_plot_C)

# Save
ggsave(paste0(path.output, "VISUAL_1C_Probabilistic_Feasibility_Space_AMMONIA.png"),
       plot = final_plot_C, width = 30, height = 16, units = "cm", bg = "white")
ggsave(paste0(path.output, "VISUAL_1C_Probabilistic_Feasibility_Space_AMMONIA.pdf"),
       plot = final_plot_C, width = 30, height = 16, units = "cm", bg = "white")
```

```{r}
summarise_q2050 <- function(dr, label, anticipation_needed) {
  df <- dr %>%
    dplyr::filter(region == "Global", anticipation == anticipation_needed) %>%
    tidyr::unnest(sensitivities) %>%
    dplyr::select(!demand) %>%
    tidyr::unnest(results) %>%
    dplyr::filter(year == 2050)

  tibble(
    Panel      = label,
    `p5 (GtCO2/a)`     = quantile(df$forecast, 0.05, na.rm = TRUE) / 1e3,
    `Median (GtCO2/a)` = quantile(df$forecast, 0.50, na.rm = TRUE) / 1e3,
    `p95 (GtCO2/a)`    = quantile(df$forecast, 0.95, na.rm = TRUE) / 1e3
  )
}

# A) Base cases
row_A_i   <- summarise_q2050(data.results.ammonia.base,   "A-i  Base  Ammonia", 5)
row_A_ii  <- summarise_q2050(data.results.naturalgas.base,"A-ii Base  LNG",     5)
row_A_iii <- summarise_q2050(data.results.wind.base,      "A-iii Base  Wind",   5)

# B) With technology policy
row_B     <- summarise_q2050(data.results.ammonia.policy, "B     With technology policy (Ammonia)", 15)

# LNG- und Wind-Mediane fr 2050 ergnzen
lng_2050   <- LNG_data_stat  %>% filter(year == 2050) %>% pull(x) / 1e3
wind_2050  <- wind_data_stat %>% filter(year == 2050) %>% pull(x) / 1e3

row_B_LNG  <- tibble(Panel = "B     With technology policy (LNG)",
                     `p5 (GtCO2/a)` = NA,
                     `Median (GtCO2/a)` = lng_2050,
                     `p95 (GtCO2/a)` = NA)

row_B_Wind <- tibble(Panel = "B     With technology policy (Wind)",
                     `p5 (GtCO2/a)` = NA,
                     `Median (GtCO2/a)` = wind_2050,
                     `p95 (GtCO2/a)` = NA)

# C) Politikhebel
row_C_i   <- summarise_q2050(data.results.capacity,     "C-i   Short-term capacity push (2030)", 5)
row_C_ii  <- summarise_q2050(data.results.anticipation, "C-ii  Long-term requirements credibility", 15)
row_C_iii <- summarise_q2050(data.results.longterm,     "C-iii Securing minimum long-term demand", 5)

# Alles zusammenfassen
summary_2050 <- bind_rows(
  row_A_i, row_A_ii, row_A_iii,
  row_B, row_B_LNG, row_B_Wind,
  row_C_i, row_C_ii, row_C_iii
)

# Referenzwert: Median aus A-i
ref_median <- row_A_i$`Median (GtCO2/a)`

# Prozentuale Abweichung berechnen
summary_2050 <- summary_2050 %>%
  mutate(
    `% vs A-i Median` = round((( `Median (GtCO2/a)` - ref_median) / ref_median) * 100, 1)
  )

# Hbsch formatieren
summary_2050 <- summary_2050 %>%
  mutate(across(where(is.numeric), ~ round(.x, 3)))

print(summary_2050)

# Als CSV speichern
readr::write_csv(summary_2050,
  file.path(path.output, "VISUAL_1.1_summary_2050_quantiles_with_deviation.csv")
)
cat(" Tabelle gespeichert unter: ",
    file.path(path.output, "VISUAL_1.1_summary_2050_quantiles_with_deviation.csv"),
    "\n")
```

#SI_Visual 4: Exponential growth phases 

```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.naturalgas,
  data.ammonia,
  data.wind.global
)

# Adjust data type
data.technologies <- data.technologies %>%
  mutate(year = as.numeric(year),
         value = as.numeric(value))


#Exponential Fits (before intervals)

## Emergence growth rate

# Ensure all technologies are assigned to the "Global" region
data.technologies <- data.technologies %>%
  mutate(region = "Global")

# Check if the data is correctly formatted and covers all regions
data.technologies <- data.technologies %>%
  arrange(region, technology, year, number) 

# Growth rate calculation
exp_fit_technologies <- function(df) {
  nlsLM(value ~ a * (1 + b)^(year - min(year)),
        data = df,
        start = list(a = 500, b = 0.05),  # Start values
        control = nls.lm.control(maxiter = 1000))  # Increased number of iterations
}


# Get growth rate
get_growthrate_technology <- function(mod) {
  coef(mod)[["b"]]
}

# Get parameter a
get_a_technology <- function(mod)
  coef(mod)[["a"]]

# Get predicted values
get_predict_technology <- function(mod)
    predict(mod)
 
# Get year
 get_year <- function(mod)
   mod$m$getEnv()$year

# Define regions manually
regions <- c("Global")

# Loop over regions and time slices

# Initialise an empty dataframe for the results
data.technologies.fit <- NULL

# Loop across regions and technologies
for (region in regions) {
  # Extract data for the region
  region_data <- data.technologies %>% filter(region == !!region)
    
    # Years available for this region and technology
      time.span <- sort(unique(region_data$year))
  
          temp <- data.technologies  %>%
            filter(region == !!region) %>% 
            group_by(technology, year) %>%
            summarise(value = sum(value), .groups = 'drop') %>%
            group_by(technology) %>%
            nest() %>%
            # Customise exponential models with purrr::map
            mutate(model.exp = map(data, exp_fit_technologies)) %>%
            transmute(technology,
                      b = map_dbl(model.exp, get_growthrate_technology),
                      a = map_dbl(model.exp, get_a_technology),
                      predict = map(model.exp, get_predict_technology),
                      year = map(model.exp, get_year),
                      region = region)
          data.technologies.fit <- bind_rows(data.technologies.fit, temp)
        }

# Remove negative growth rates
data.technologies.fit <- data.technologies.fit %>%
  filter(b > 0)

# Ergebnisse anzeigen
print(data.technologies.fit %>% select(technology, region, b))

# Plot for parameter distributions

 data.plot.fit <- data.technologies.fit %>%
  unnest(c(year, predict)) %>%
  filter(region == "Global") %>%
  group_by(technology) %>%
  filter(!is.na(predict))  # Only include data points with valid predictions

data.plot <- data.technologies %>%
  filter(region == "Global")

facet_labels <- c(
  "Ammonia Synthesis" = "[tons/a]",
  "LNG" = "[million tons/a]",
  "Wind" = "[MW]"
)

# Ensure that only data up to the last year of the existing data set is plotted
max_year <- max(data.plot$year, na.rm = TRUE)  # Bestimme das letzte Jahr mit Daten

p <- ggplot() +
  geom_point(data = data.plot, mapping = aes(x = year, y = value, color = technology), 
             size = 0.5) +
  # Make sure that only data up to max_year is used for the fit
  geom_line(data = data.plot.fit %>% filter(year <= max_year),  
            mapping = aes(x = year, y = predict, color = technology), 
            na.rm = TRUE) +  
  
  scale_y_continuous(labels = scales::label_number(scale = 1, accuracy = 1)) +
  scale_color_manual(values = c(
    "Ammonia Synthesis" = "#E64B35FF",
    "LNG" = "#51A492",
    "Wind" = "blue"
  )) +
  
  facet_grid(technology ~ region, scales = "free_y", 
             labeller = labeller(technology = facet_labels)) +

  labs(
    x = "Year",
    y = NULL,  
    color = "Analog Technologies"
  ) +
  
# Theme adjustments for font size and colour
  theme_minimal(base_size = 10) + # Base font size
  theme(
    axis.title = element_text(size = 10, colour = "black"), # axis title
    axis.text = element_text(size = 10, colour = "black"), # axis text (labels)
    strip.text = element_text(size = 10, colour = "black"), # Headings for facets
    plot.title = element_text(size = 10, face = "bold", colour = "black"), # main title
    legend.title = element_text(size = 10, colour = "black"), # Legend title
    legend.text = element_text(size = 10, colour = "black") # Legend text
  )
# Show plot
print(p)

# Save the final plot with adjusted dimensions
ggsave(paste0(path.output, "VISUAL_4_Exponential_Growth_Phases.png"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
ggsave(paste0(path.output, "VISUAL_4_Exponential_Growth_Phases.pdf"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
```



#WIND 2100

```{r}
# For plotting
t.max <<- 2100
print(t.max) 
```

# DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.wind.global
)
# Adjust data type
data.technologies <- data.technologies %>%
  mutate(year = as.numeric(year),
         value = as.numeric(value))
```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))
print(data.technologies.fit %>% select(technology, region, b))
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "Wind" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/19_WIND_ENERGY_2100_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/20_WIND_ENERGY_2100_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/19_WIND_ENERGY_2100_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/20_WIND_ENERGY_2100_growth_sample.rds")
}
```

# A) Base case (without enhanced technology policy)

## Demand pull  
```{r}
# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
      demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results,
          "02_output_plots_new/08_WIND_ENERGY_2100_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results <-
    readRDS("02_output_plots_new/08_WIND_ENERGY_2100_BASE_CASE_results.rds")
}
```
```{r}
# Extract data from data.results and convert it into a DataFrame
data_to_save_Wind_BaseCase <- data.results %>%
  filter(region %in% c("Global", "Europe", "North America"), anticipation == 15) %>% 
  unnest(sensitivities) %>% 
  select(-demand) %>% 
  unnest(results) %>%  
  select(region, anticipation, year, forecast)

# Save CSV Data
write.csv(data_to_save_Wind_BaseCase, paste0
(path.output,"SUBVISUAL_A_Probabilistic_Feasibility_Space_BaseCase_Wind_2100.csv"), 
          row.names = FALSE)
cat("The data has been successfully saved in the CSV file.")
```

# C, i) Individual technology policy levers (i) policy push fostering short-term DAC capacity (capacity.factor = 10)) 

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
  
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "Wind"  
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/21_WIND_ENERGY_2100_CI_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/22_WIND_ENERGY_2100_CI_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/21_WIND_ENERGY_2100_CI_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/22_WIND_ENERGY_2100_CI_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                    by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                        fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
      demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.capacity <-
    calcTechnologyDiffusionCapacity(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.capacity,
          "02_output_plots_new/09_WIND_ENERGY_2100_CI_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.capacity <-
    readRDS("02_output_plots_new/09_WIND_ENERGY_2100_CI_results.rds")
}
```

#SI_Visual_5b: Base case + C, i) policy push (capacity.factor = 10)

```{r}
plotCombinedFeasibilitySpace <- function(base_case_row,
                                         capacity_factor_row,
                                         colour,
                                         median_colour,
                                         title,
                                         ci.80 = F,  # 80% confidence int.
                                         slices = 100,
                                         random.paths = 10,
                                         zoom.panel = F,
                                         text_height_offset = 0.1) { 
  
  # Unnest results for Base Case
  base_plot <- base_case_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Unnest results for capacity.factor = 10
  capacity_factor_plot <- capacity_factor_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Calculate median of capacity.factor = 10 forecasts
  median_capacity <- capacity_factor_plot %>%
    group_by(year) %>%
    summarise(median_forecast = median(forecast, na.rm = TRUE), .groups = 'drop')
  
  # Quantile calcuation for Base case
  quantiles <- c(0.95, 0.5, 0.05)
  col.quant <- c("0.95" = darken(colour, 0.1),
                 "0.5" = darken(colour, 0.5),
                 "0.05" = darken(colour, 0.1))
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  
  data.stat <- base_plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Select random paths for base case
  data.plot.random <- base_plot %>%
    filter(sample %in% sample(1:max(base_plot$sample), random.paths))
  
  # Density for base case
  data.raster <- NULL
  for (y in unique(base_plot$year)) {
    # Select
    subset <- base_plot %>%
      filter(year == y) %>%
      pull(forecast)
    # Density
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(base_plot$forecast, na.rm = T)
    )
    # Normalise
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    # Save
    data.raster <- bind_rows(data.raster, temp)
  }

   # Median for base case
  base_case_median <- data.stat %>% filter(q == 0.5)
  marginal.year <- max(base_case_median$year)
  
  # Calculation of the percentage deviation
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- median_capacity %>% filter(year == marginal.year) %>%
    pull(median_forecast)
  percentage_difference <- round(((current_median_value - base_median_value) 
                                  / base_median_value) * 100)

  # Text for displaying the deviation
text_label <- paste0("~ ", percentage_difference, " %") 

  
  # Plot
  p.facet <- ggplot() +
    # Density
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability Density\n(normalised)", low = "white", 
                        high = colour) +
    # Random paths for base case
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example Path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example Path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    # Median line from capacity.factor = 10
    geom_line(
      data = median_capacity,
      mapping = aes(x = year, y = median_forecast),
      color = median_colour,
      size = 1,
      linetype = "dashed"
    ) +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    # Quantiles
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.5" = "50 % (Median)",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
   xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
     ggtitle(title) +
    annotate("text", 
             x = max(data.stat$year) + 1, 
             y = current_median_value + text_height_offset * current_median_value,  
             label = text_label, 
             hjust = 1, 
             size = 2.5, 
             color = "black") +
    theme(
      legend.position = c(0.1, 0.9),  
      legend.justification = c(0, 1), 
      legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
      plot.title = element_text(face = "bold", size = font.size)
    )
  
  return(p.facet)
}

# Define colors
mycolors <- c("#66AFC0", "#66AFC0", "#DC0000FF") 
base_case_colour <- mycolors[1]
capacity_factor_colour <- mycolors[3]

# Create new figures
p1 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Europe", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Europe", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Europe",
  text_height_offset = 0.2 
)

p2 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "North America", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "North America", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "North America",
  text_height_offset = 0.2 
)

p3 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Global", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Global", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Global",
  text_height_offset = 0.2 
)

# Combine the plots
p_combined <- plot_grid(p1, p2, p3,
                        ncol = 3,
                        rel_widths = c(1, 1, 1),
                        labels = c("a", "b", "c"),
                        label_size = font.size)

# Print and save the combined plot
print(p_combined)
ggsave(paste0(path.output, "SI_Visual_5b_Combined_Feasibility_Space_Wind_2100.png"),
       width = 20, height = 15, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_Visual_5b_Combined_Feasibility_Space_Wind_2100.pdf"),
       width = 20, height = 15, units = "cm", bg = "white")

```

# B) Enhanced Policy Case


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
  
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "Wind"  
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/23_WIND_ENERGY_2100_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/24_WIND_ENERGY_2100_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/23_WIND_ENERGY_2100_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/24_WIND_ENERGY_2100_POLICY_CASE_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, 
                             dac_target_policy = policy_case_dac_targets)
# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                           fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
  demand = demand))), by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.policy <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.policy,
          "02_output_plots_new/10_WIND_ENERGY_2100_POLICY_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.policy <-
    readRDS("02_output_plots_new/10_WIND_ENERGY_2100_POLICY_CASE_results.rds")
}
```


```{r}
# Extract data from data.results.policy and convert it into a DataFrame
data_to_save_wind <- data.results.policy %>%
  filter(region %in% c("Global", "Europe", "North America"), anticipation == 15) %>%  
  unnest(sensitivities) %>% 
  select(-demand) %>%  
  unnest(results) %>% 
  select(region, anticipation, year, forecast)  

# Save CSV data
write.csv(data_to_save_wind, paste0(path.output,                             "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind_2100.csv"), 
          row.names = FALSE)

cat("The data has been successfully saved in the CSV file.")

```


#LNG 2100

# DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

## Input data

### Global Liquid Natural Gas (Capacity) (Greene, J., Nemet, G., Hammersmith, A. & Zaiser, A. The Historical Adoption of TeCHnology (HATCH) Dataset. (2023).)

```{r}
data.naturalgas <- tibble(
 
#DATA HATCH DATABASE: Global Liquefied Natural Gas Plants (millon tons per year)
year = c(#1970, 1972, 1973, 
         1974, 1977, 1978,1981, 1983,1989,1992,1993, 1994, 1995, 1996, 1997, 1998, 
         1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 
         2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020),

 production = c(#3.2, 6.08, 8.96, 
                10.4, 11.84, 13.28, 14.72, 16.16, 17.6, 19.02, 20.48, 21.92, 23.36,	
                24.8,	26.24,	27.68,	29.12,	30.56, 32,	33.44,	34.88,	36.32, 
                37.76,	39.2,	40.64, 42.08,	43.52, 44.96, 46.4, 47.84, 49.28, 50.72, 
                52.16,	53.6,	55.04,	56.48,	57.92)
) %>% 
  mutate(value = production,
         region = "Global",
         technology = "LNG",
         #unit = "MW",
         unit = "million tons/yr",
         tech = "LNG",
         number = 4) %>%
         select(year, value, region, technology, unit, tech, number) %>%
         arrange(year)
```


```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.naturalgas
)

# Adjust data type
data.technologies <- data.technologies %>%
  mutate(year = as.numeric(year),
         value = as.numeric(value))

```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))

print(data.technologies.fit %>% select(technology, region, b))
``` 

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1,
    
    #Technnology
    technology = "LNG" 
    
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/25_LNG_2100_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/26_LNG_2100_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/25_LNG_2100_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/26_LNG_2100_growth_sample.rds")
}
```


# A) Base case (without enhanced technology policy)

## Demand pull  
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                    by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
    demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results,
          "02_output_plots_new/11_LNG_2100_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results <-
    readRDS("02_output_plots_new/11_LNG_2100_BASE_CASE_results.rds")
}
```


```{r}
# Extract data from data.results and convert it into a DataFrame
data_to_save_LNG_BaseCase <- data.results %>%
  filter(region %in% c("Global", "Europe", "North America"), anticipation == 15) %>% 
  unnest(sensitivities) %>% 
  select(-demand) %>% 
  unnest(results) %>%  
  select(region, anticipation, year, forecast)

# Save CSV Data
write.csv(data_to_save_LNG_BaseCase, paste0(path.output, "SUBVISUAL_A_Probabilistic_Feasibility_Space_BaseCase_LNG_2100.csv"), row.names = FALSE)

cat("The data has been successfully saved in the CSV file.")

```


# C, i) Individual technology policy levers (i) policy push fostering short-term DAC capacity (capacity.factor = 10)) 

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
  
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "LNG"  
    
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/27_LNG_2100_CI_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/28_LNG_2100_CI_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/27_LNG_2100_CI_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/28_LNG_2100_CI_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                          fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
      demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation
```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.capacity <-
    calcTechnologyDiffusionCapacity(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.capacity,
          "02_output_plots_new/12_LNG_2100_CI_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.capacity <-
    readRDS("02_output_plots_new/12_LNG_2100_CI_results.rds")
}
```
#SI_Visual_5c: Base case + C, i) policy push (capacity.factor = 10)

```{r}
plotCombinedFeasibilitySpace <- function(base_case_row,
                                         capacity_factor_row,
                                         colour,
                                         median_colour,
                                         title,
                                         ci.80 = F,  # 80% confidence int.
                                         slices = 500,
                                         random.paths = 10,
                                         zoom.panel = F,
                                         text_height_offset = 0.1) { 
  
  # Unnest results for Base Case
  base_plot <- base_case_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Unnest results for capacity.factor = 10
  capacity_factor_plot <- capacity_factor_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Calculate median of capacity.factor = 10 forecasts
  median_capacity <- capacity_factor_plot %>%
    group_by(year) %>%
    summarise(median_forecast = median(forecast, na.rm = TRUE), .groups = 'drop')
  
  # Quantile calcuation for Base case
  quantiles <- c(0.95, 0.5, 0.05)
  col.quant <- c("0.95" = darken(colour, 0.1),
                 "0.5" = darken(colour, 0.5),
                 "0.05" = darken(colour, 0.1))
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  
  data.stat <- base_plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Select random paths for base case
  data.plot.random <- base_plot %>%
    filter(sample %in% sample(1:max(base_plot$sample), random.paths))
  
  # Density for base case
  data.raster <- NULL
  for (y in unique(base_plot$year)) {
    # Select
    subset <- base_plot %>%
      filter(year == y) %>%
      pull(forecast)
    # Density
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(base_plot$forecast, na.rm = T)
    )
    # Normalise
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    # Save
    data.raster <- bind_rows(data.raster, temp)
  }

   # Median for base case
  base_case_median <- data.stat %>% filter(q == 0.5)
  marginal.year <- max(base_case_median$year)
  
  # Calculation of the percentage deviation
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- median_capacity %>% 
    filter(year == marginal.year) %>% pull(median_forecast)
  percentage_difference <- round(((current_median_value - base_median_value) /
                                    base_median_value) * 100)

  # Text for displaying the deviation
text_label <- paste0("~ ", percentage_difference, " %") 

  
  # Plot
  p.facet <- ggplot() +
    # Density
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability Density\n(normalised)", low = "white", 
                        high = colour) +
    # Random paths for base case
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example Path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example Path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    # Median line from capacity.factor = 10
    geom_line(
      data = median_capacity,
      mapping = aes(x = year, y = median_forecast),
      color = median_colour,
      size = 1,
      linetype = "dashed"
    ) +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    # Quantiles
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.5" = "50 % (Median)",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
   xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
     ggtitle(title) +
    annotate("text", 
             x = max(data.stat$year) + 1, 
             y = current_median_value + text_height_offset * current_median_value,
             label = text_label, 
             hjust = 1, 
             size = 2.5, 
             color = "black") +
    theme(
      legend.position = c(0.1, 0.9),  
      legend.justification = c(0, 1), 
      legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
      plot.title = element_text(face = "bold", size = font.size)
    )
  
  return(p.facet)
}

# Define colors
mycolors <- c("#00A087FF", "#66AFC0", "#DC0000FF") 
base_case_colour <- mycolors[1]
capacity_factor_colour <- mycolors[3]

# Create new figures
p1 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Europe", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Europe", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Europe",
  text_height_offset = 0.2 
)

p2 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "North America", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "North America", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "North America",
  text_height_offset = 0.2 
)

p3 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Global", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Global", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Global",
  text_height_offset = 0.2 
)

# Combine the plots
p_combined <- plot_grid(p1, p2, p3,
                        ncol = 3,
                        rel_widths = c(1, 1, 1),
                        labels = c("a", "b", "c"),
                        label_size = font.size)

# Print and save the combined plot
print(p_combined)
ggsave(paste0(path.output, "SI_Visual_5c_Combined_Feasibility_Space_LNG_2100.png"),
       width = 20, height = 15, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_Visual_5c_Combined_Feasibility_Space_LNG_2100.pdf"),
       width = 20, height = 15, units = "cm", bg = "white")

```

# B) Enhanced Policy Case

## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
  
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10,
    
    #Technnology
    technology = "LNG" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/29_LNG_2100_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/30_LNG_2100_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/29_LNG_2100_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/30_LNG_2100_POLICY_CASE_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
    demand = demand))), by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation
```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.policy <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.policy,
          "02_output_plots_new/13_LNG_2100_POLICY_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.policy <-
    readRDS("02_output_plots_new/13_LNG_2100_POLICY_CASE_results.rds")
}
```

```{r}
# Extract data from data.results.policy and convert it into a DataFrame
data_to_save_LNG <- data.results.policy %>%
  filter(region %in% c("Global", "Europe", "North America"), anticipation == 15) %>%  
  unnest(sensitivities) %>% 
  select(-demand) %>%  
  unnest(results) %>% 
  select(region, anticipation, year, forecast)  

# Save CSV data
write.csv(data_to_save_LNG, paste0(path.output,                                   "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG_2100.csv"), 
          row.names = FALSE)
cat("The data has been successfully saved in the CSV file.")
```


#AMMONIA SYNTHESIS 2100

# DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```

## Input data

### Global Ammonia Synthesis Production (Global Annual Production) (Roberts and Nemet, 2024)

```{r}
#Commented out values which do not represent the exponential growth of this technology
data.ammonia <- tibble(
  year = c(#1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 
    1932, 1933, 1934, 1935, 1936, 1937, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 
    1955, 1956, 1957, 1958, 1959
           #, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 
    #1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 
    #1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 
    #1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 
    #2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
  ),
  production = c(#367, 485, 442.1, 439.1, 522.2, 560, 534.7, 533, 
    630, 654, 1061, 3589.987, 3956.773, 4462.385,13544.151, 15477.434, 17609.862, 
    20325.168, 23070.228, 25836.183, 28141.97, 30195.308, 33258.266, 35249.174, 
    38350.337, 41033.282 #, 42414.805, 44619.593, 46449.524, 50468.029, 55909.463, 
    #59622.703, 62777.606, 62291.849, 63493.886, 68268.923, 74855.695, 73680.818, 
    #77696.274, 82028.36, 85767.301, 85185.849, 82279.841, 80831.186, 80314.695, 
    #80302.72, 80011.675, 86486.98, 90418.464, 87566.043, 88392.236, 89161.871, 
    #85129.097, 85670.741, 87334.65659, 88722.23565, 94211.27627, 95401.6224, 
    #95157.92192, 102402.8279, 100266.5045, 98588.04969, 107431.9324, 107783.99, 
    #109821.5327, 114908.875, 115823.0681, 120785.4006, 119405.796, 120677.587, 
    #121230.526, 123987.3633, 123145.0518, 98588.04969, 107431.9324, 107783.99, 
    #109821.5327, 114908.875, 115823.0681, 120785.4006, 119405.796, 120677.587, 
    #121230.526, 123987.3633, 123145.0518
 )
) %>%
  mutate(value = production,
         region = "Global",
         technology = "Ammonia Synthesis",
         unit = "Tons per year",
         tech = "Global Annual Ammonia Synthesis Production",
         number = 5) %>%
         select(year, value, region, technology, unit, tech, number) %>%
         arrange(year)
```


```{r}
# Summarize all technologies for analysis (see Roberts and Nemet, 2024)
data.technologies <- bind_rows(
  data.ammonia
)

# Adjust data type
data.technologies <- data.technologies %>%
mutate(year = as.numeric(year),
         value = as.numeric(value))

```

##Emergence growth rate
```{r}
# Call the function to calculate the growth rates
data.technologies.fit <- calcEmergenceGrowthRate(data.technologies, regions = c("Global"))

print(data.technologies.fit %>% select(technology, region, b))
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
    
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1, 
    
    #Technnology
    technology = "Ammonia Synthesis"
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/31_AMMONIA_SYNTHESIS_2100_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/32_AMMONIA_SYNTHESIS_2100_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/31_AMMONIA_SYNTHESIS_2100_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/32_AMMONIA_SYNTHESIS_2100_growth_sample.rds")
}
```

# A) Base case (without enhanced technology policy)

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                    by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                          fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
      demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results <-
  calcTechnologyDiffusion(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results,
          "02_output_plots_new/14_AMMONIA_SYNTHESIS_2100_BASE_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results <-
    readRDS("02_output_plots_new/14_AMMONIA_SYNTHESIS_2100_BASE_CASE_results.rds")
}
```

#SI_Visual 6: with medians of wind energy and LNG
```{r}
# Define plot function with Median Paths
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour,
                                              title,
                                              ci.80 = F,
                                              slices = 100,
                                              random.paths = 10,
                                              LNG_data_stat = NULL,  
                                              wind_data_stat = NULL,  
                                              text_offset_LNG = 5, 
                                              text_offset_wind = 6) { 
  
  # Unnest results
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Calculate quantiles
  quantiles <- c(0.95, 0.5, 0.05)
  col.quant <- c("0.95" = darken(colour, 0.1),
                 "0.5" = darken(colour, 0.5),
                 "0.05" = darken(colour, 0.1))
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  
  # Median and percentiles calculation
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Density calculation
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(data.plot$forecast, na.rm = T)
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y, forecast = dens$x, density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Median Base Case Value (50% Quantile)
  base_case_median <- data.stat %>% filter(q == 0.5)
  
  # Base plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability Density\n(normalised)", low = "white", high = colour) +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      size = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.5" = "50 % (Median)",
                                  "0.05" = "5 %")) +
    xlab("year") +
    scale_x_continuous(
      breaks = seq(2030, 2100, by = 10)
    ) +
    ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
    scale_y_continuous(
      labels = scales::label_number(scale = 1e-3),
      expand = expansion(mult = c(0.01, 0.05)),
      limits = c(0, 6000),
      breaks = seq(0, 6000, by = 500)
    ) +
    ggtitle(title) +
    theme(
      legend.position = c(0.1, 0.9), 
      legend.justification = c(0, 1),  
      legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
      plot.title = element_text(face = "bold", size = font.size)
    )
  
# LNG median
if (!is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == max(base_case_median$year)) %>% 
    pull(x)
  base_median_value <- base_case_median %>% 
    filter(year == max(base_case_median$year)) %>% pull(x)
  LNG_percentage_difference <- round(((LNG_median_value - base_median_value) /
                                        base_median_value) * 100)
  p.facet <- p.facet +
    geom_line(
      data = LNG_data_stat,
      aes(x = year, y = x),
      linetype = "dashed",
      color = "#00A087FF",  # LNG color
      size = 0.8
    ) +
    annotate("text", 
             x = max(base_case_median$year) + 1, 
             y = LNG_median_value + text_offset_LNG,  
             label = paste0("~ ", LNG_percentage_difference, " %  LNG"), 
             hjust = 1, size = 2.5, color = "#00A087FF")
}

# Wind median
if (!is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == max(base_case_median$year)) %>% 
    pull(x)
  wind_percentage_difference <- round(((wind_median_value - base_median_value) /
                                         base_median_value) * 100)
  p.facet <- p.facet +
    geom_line(
      data = wind_data_stat,
      aes(x = year, y = x),
      linetype = "dashed",
      color = "blue",  # Wind color
      size = 0.8
    ) +
    annotate("text", 
             x = max(base_case_median$year) + 1, 
             y = LNG_median_value + text_offset_LNG + 200,  
             label = paste0("~ ", wind_percentage_difference, " %  Wind"), 
             hjust = 1, size = 2.5, color = "blue")
}

  return(p.facet)
}


# Define your colors
mycolors <- c("#F39B7FFF", "#66AFC0", "#7A9DCF", "#E2AEAB")
colours <- mycolors

# Load LNG and Wind data
LNG_data <- read.csv(here("02_output_plots_new",
          "SUBVISUAL_A_Probabilistic_Feasibility_Space_BaseCase_LNG_2100.csv"))
wind_data <- read.csv(here("02_output_plots_new",
        "SUBVISUAL_A_Probabilistic_Feasibility_Space_BaseCase_Wind_2100.csv"))

# Calculate median paths
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))

wind_data_stat <- wind_data %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))

# Create plot
p1 <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "Europe", anticipation == 5),
  colour = colours[1],
  title = "Europe",
  LNG_data_stat = LNG_data_stat,
  wind_data_stat = wind_data_stat,
  text_offset_LNG = 5000
)

p2 <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "North America", anticipation == 5),
  colour = colours[1],
  title = "North America",
  LNG_data_stat = LNG_data_stat,
  wind_data_stat = wind_data_stat,
  text_offset_LNG = 5000
)

p3 <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "Global", anticipation == 5),
  colour = colours[1],
  title = "Global",
  LNG_data_stat = LNG_data_stat,
  wind_data_stat = wind_data_stat,
  text_offset_LNG = 5000
)

# Combine the plots
p.plots <- plot_grid(p1, p2, p3,
                     ncol = 3,
                     rel_widths = c(1, 1, 1),
                     labels = c("a", "b", "c"),
                     label_size = font.size)
print(p.plots)

ggsave(paste0(path.output, "SI_Visual_6_Probabilistic_Feasibility_Space_BaseCase_With_Medians.png"),
       plot = p.plots, width = 20, height = 8, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_Visual_6_Probabilistic_Feasibility_Space_BaseCase_With_Medians.pdf"),
       plot = p.plots, width = 20, height = 8, units = "cm", bg = "white")

```

# C, i) Individual technology policy levers (i) policy push fostering short-term DAC capacity (capacity.factor = 10)) 

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```

```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10, 
    
    #Technnology
    technology = "Ammonia Synthesis"
    
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/33_AMMONIA_SYNTHESIS_2100_CI_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/34_AMMONIA_SYNTHESIS_2100_CI_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/33_AMMONIA_SYNTHESIS_2100_CI_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/34_AMMONIA_SYNTHESIS_2100_CI_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                    by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year,
    demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.capacity <-
    calcTechnologyDiffusionCapacity(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.capacity,
          "02_output_plots_new/15_AMMONIA_SYNTHESIS_2100_CI_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.capacity <-
    readRDS("02_output_plots_new/15_AMMONIA_SYNTHESIS_2100_CI_results.rds")
}
```

#SI_Visual_5a: Base case + C, i) policy push (capacity.factor = 10)

```{r}
plotCombinedFeasibilitySpace <- function(base_case_row,
                                         capacity_factor_row,
                                         colour,
                                         median_colour,
                                         title,
                                         ci.80 = F,  # 80% confidence interval
                                         slices = 100,
                                         random.paths = 10,
                                         zoom.panel = F,
                                         text_height_offset = 0.1) { 
  
  # Unnest results for Base Case
  base_plot <- base_case_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Unnest results for Capacity Factor = 10
  capacity_factor_plot <- capacity_factor_row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Calculate median of Capacity Factor = 10 forecasts
  median_capacity <- capacity_factor_plot %>%
    group_by(year) %>%
    summarise(median_forecast = median(forecast, na.rm = TRUE), .groups = 'drop')
  
  # Quantile calculation for Base Case
  quantiles <- c(0.95, 0.5, 0.05)
  col.quant <- c("0.95" = darken(colour, 0.1),
                 "0.5" = darken(colour, 0.5),
                 "0.05" = darken(colour, 0.1))
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  
  data.stat <- base_plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Select random paths for Base Case
  data.plot.random <- base_plot %>%
    filter(sample %in% sample(1:max(base_plot$sample), random.paths))
  
  # Density for Base Case
  data.raster <- NULL
  for (y in unique(base_plot$year)) {
    # Select
    subset <- base_plot %>%
      filter(year == y) %>%
      pull(forecast)
    # Density
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = max(base_plot$forecast, na.rm = T)
    )
    # Normalise
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    # Save
    data.raster <- bind_rows(data.raster, temp)
  }

  # Median for Base Case
  base_case_median <- data.stat %>% filter(q == 0.5)
  marginal.year <- max(base_case_median$year)
  

# Calculation of percentage deviation
base_median_value <- base_case_median %>% filter(year == marginal.year) %>% 
  pull(x)
current_median_value <- median_capacity %>% 
  filter(year == marginal.year) %>% pull(median_forecast)
percentage_difference <- round(((current_median_value - base_median_value) / 
                                  base_median_value) * 100)

# Text for displaying the deviation
text_label <- paste0("~ ", percentage_difference, " %")  # Show as whole number

# Plot
p.facet <- ggplot() +
  # Density
  geom_tile(
    data = data.raster,
    mapping = aes(x = year, y = forecast, fill = density)
  ) +
  scale_fill_gradient(name = "Probability Density\n(normalised)", low = "white", 
                      high = colour) +
  # Random paths for Base Case
  geom_line(
    data = data.plot.random,
    mapping = aes(
      x = year,
      y = forecast,
      group = sample,
      color = "Example Path"
    ),
    lwd = 0.5,
    alpha = 0.5
  ) +
  scale_color_manual(
    values = c("Example Path" = "grey"),
    name = NULL,
    guide = guide_legend(order = 3)
  ) +
  new_scale_color() +
  # Median line for Capacity Factor = 10
  geom_line(
    data = median_capacity,
    mapping = aes(x = year, y = median_forecast),
    color = median_colour,
    size = 1,
    linetype = "dashed"
  ) +
  geom_line(
    data = data.stat,
    mapping = aes(x = year, y = x, color = q),
    size = 1
  ) +
  # Quantiles
  scale_color_manual(values = col.quant,
                     name = "Percentiles",
                     labels = c("0.95" = "95 %",
                                "0.5" = "50 % (Median)",
                                "0.05" = "5 %"),
                     guide = guide_legend(order = 4)) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
  ggtitle(title) +
  annotate(
    "text", 
    x = max(data.stat$year) + 1, 
    y = current_median_value + text_height_offset * current_median_value, 
    label = text_label, 
    hjust = 1, 
    size = 2.5, 
    color = "black"
  ) +
  theme(
    legend.position = c(0.1, 0.9),  # Position of the legend at top left
    legend.justification = c(0, 1),  # Align at top left
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )

  
  return(p.facet)
}

# Define colors
mycolors <- c("#F39B7FFF", "#66AFC0", "#DC0000FF") 
base_case_colour <- mycolors[1]
capacity_factor_colour <- mycolors[3]

# Create new figures
p1 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Europe", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Europe", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Europe",
  text_height_offset = 0.02 
)

p2 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% 
    filter(region == "North America", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "North America", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "North America",
  text_height_offset = 0.2 
)

p3 <- plotCombinedFeasibilitySpace(
  base_case_row = data.results %>% filter(region == "Global", anticipation == 5),
  capacity_factor_row = data.results.capacity %>% 
    filter(region == "Global", anticipation == 5),
  colour = base_case_colour,
  median_colour = capacity_factor_colour,
  title = "Global",
  text_height_offset = 0.2 
)

# Main centered title
title <- ggdraw() + 
  draw_label(
    "Global DAC Capacity in 2100",
    fontface = 'bold',
    size = 10,  # Adjust size as needed
    hjust = 0.5,  # Centered
    vjust = 0.1 # Adjust to increase spacing below the title
  )

# Combine the plots
p_combined <- plot_grid(p1, p2, p3,
                        ncol = 3,
                        rel_widths = c(1, 1, 1),
                        labels = c("a", "b", "c"),
                        label_size = font.size)

# Print and save the combined plot
print(p_combined)
ggsave(paste0(path.output, "SI_Visual5a_Combined_Feasibility_Space.png"),
       width = 20, height = 8, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_Visual5a_Combined_Feasibility_Space.pdf"),
       width = 20, height = 8, units = "cm", bg = "white")


```


# C, ii) Individual technology policy levers (ii) creating credibility in long-term DAC requirements (anticipation))

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1, 
    
    #Technnology
    technology = "Ammonia Synthesis"
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/35_AMMONIA_SYNTHESIS_2100_CII_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/36_AMMONIA_SYNTHESIS_2100_CII_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/35_AMMONIA_SYNTHESIS_2100_CII_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/36_AMMONIA_SYNTHESIS_2100_CII_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_base value
dac_targets_df <- data.frame(sample = samples, dac_target_base = base_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_base into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                    by = .(key, sample, dac_target_base, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_base / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                          fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
      demand = demand))), by = .(region, anticipation, sample, dac_target_base)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)
```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.anticipation <-
    calcTechnologyDiffusionAnticipation(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.anticipation,
          "02_output_plots_new/16_AMMONIA_SYNTHESIS_2100_CII_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.anticipation <-
    readRDS("02_output_plots_new/16_AMMONIA_SYNTHESIS_2100_CII_results.rds")
}
```
# B) Enhanced Policy Case


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 10
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,
  
    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 10, 
    
    #Technnology
    technology = "Ammonia Synthesis" 
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/37_AMMONIA_SYNTHESIS_2100_POLICY_CASE_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/38_AMMONIA_SYNTHESIS_2100_POLICY_CASE_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/37_AMMONIA_SYNTHESIS_2100_POLICY_CASE_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/38_AMMONIA_SYNTHESIS_2100_POLICY_CASE_growth_sample.rds")
}
```


## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                  by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
    demand = demand))), by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.policy <-
    calcTechnologyDiffusionPolicy(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.policy,
          "02_output_plots_new/17_AMMONIA_SYNTHESIS_2100_POLICY_CASE_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.policy <-
    readRDS("02_output_plots_new/17_AMMONIA_SYNTHESIS_2100_CII_results.rds")
}
```

# C, iii) Individual technology policy levers (iii) Long-term Market Growth)


## DAC Projects Database

```{r, message = FALSE}
# DAC Projects Database
file.dacprojects <- paste0(path.input, "Capacity DAC Projects Database 2024.xlsx")
data.dac <- ReadDACProjectsDB(
  file.dacprojects,
  dacprojects.range = "A5:N82",
  capacity.factor = 1
)
```


```{r, message = FALSE}
# Region mapping and running the Monte Carlo simulation
if (model.mode == "simulation") {
  temp <- calcMonteCarloSample(
    # Sample size
    N = n,
    # Initial value distribution
    a.status = c("Decommissioned", "Operational", "Under Construction"),
    # Lower truncation = a 
    cap.1 = c("Decommissioned", "Operational", "Under Construction", "FID"),
    # Condition 1
    cumprob.1 = 0.15, # 15% probability for FID
    # Cumulative probability of condition 1
    feasibilityAndDEP.success.rate = 0.3,

    # Length of time slice
    slice.len = 7,
    
    # Growth rate distribution
    b.min = bmin, # Lower truncation
    
    #Capacity factor 
    capacity.factor = 1, 
    
    #Technnology
    technology = "Ammonia Synthesis"
    )
  data.input <- temp[[1]]
  data.input.param <- temp[[2]]
  saveRDS(data.input.param,
          "02_output_plots_new/39_AMMONIA_SYNTHESIS_2100_CIII_growth_parameters.rds")
  saveRDS(data.input,
          "02_output_plots_new/40_AMMONIA_SYNTHESIS_2100_CIII_growth_sample.rds")
} else if (model.mode == "reproduction") {
  data.input.param <-
    readRDS("02_output_plots_new/39_AMMONIA_SYNTHESIS_2100_CIII_growth_parameters.rds")
  data.input <-
    readRDS("02_output_plots_new/40_AMMONIA_SYNTHESIS_2100_CIII_growth_sample.rds")
}
```

## Demand pull 
```{r}

# Define your anticipation scenarios and model time frame
anticipation <- c(5, 15)
model.time <- t.split:t.max
regions <- c("Europe", "North America", "Global")
samples <- 1:n  # Sample numbers from 1 to n

# Create a data frame associating each sample with a dac_target_policy value
dac_targets_df <- data.frame(sample = samples, dac_target_policy = policy_case_dac_targets)

# Prepare combinations of sample, anticipation, and region
combinations <- expand.grid(
  sample = samples,
  anticipation = anticipation,
  region = regions,
  stringsAsFactors = FALSE
)

# Merge dac_target_policy into combinations using the sample identifier
combinations <- merge(combinations, dac_targets_df, by = "sample")

# Add a unique key to identify each combination
combinations$key <- seq_len(nrow(combinations))

# Convert to data.table for efficient processing
combinations_dt <- as.data.table(combinations)
years_dt <- data.table(year = model.time)

# Cross join combinations with years
combinations_with_year_dt <- combinations_dt[, .(year = years_dt$year), 
                 by = .(key, sample, dac_target_policy, anticipation, region)]

# Calculate the linear demand without anticipation
combinations_with_year_dt[, slope := dac_target_policy / (t.max - t.split)]
combinations_with_year_dt[, demand := pmax(slope * (year - t.split), 0)]

# Apply anticipation by shifting the demand
combinations_with_year_dt[, demand := shift(demand, n = anticipation, type = "lead", 
                                            fill = last(demand)), by = key]

# Nest the demand data
data.demand <- combinations_with_year_dt[, .(demand = list(data.frame(year = year, 
    demand = demand))), by = .(region, anticipation, sample, dac_target_policy)]

# Convert data.demand back to data.frame if necessary
data.demand <- as.data.frame(data.demand)


```

## Call simulation

```{r, message = F}
# Simulation mode
if (model.mode == "simulation") {
  # Keep track of time
  start.time <- Sys.time()
  # Call diffusion model
  data.results.longterm <-
    calcTechnologyDiffusionLongterm(data.demand, data.input, 0.25)
  # Save simulation results
  saveRDS(data.results.longterm,
          "02_output_plots_new/18_AMMONIA_SYNTHESIS_2100_CIII_results.rds")
  # Print duration of simulation
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  # Reproduction mode
} else if (model.mode == "reproduction") {
  data.results.longterm <-
    readRDS("02_output_plots_new/18_AMMONIA_SYNTHESIS_2100_CIII_results.rds")
}
```

#SI_Visual 7: A) Base case versus B) Enhanced policy case and C) individual policy levers (Global)

```{r}
# Colours out of pal_npg-Palette
colours <- pal_npg("nrc")(10) 

# Loading CSV data
LNG_data <- read.csv(here("02_output_plots_new",                    "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG_2100.csv"))
wind_data <- read.csv(here("02_output_plots_new",     "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind_2100.csv"))

# Calculating median of LNG data
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Calculating median of wind energy data
wind_data_stat <- wind_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Function for creating plots with consistent colouring
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour_index,
                                              title,
                                              dac_target_base,
                                              ci.80 = F,  # 80% Confidence interval
                                              slices = 1000,
                                              random.paths = 10,
                                              zoom.panel = F) { 
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  }
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }

  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))

  # Receive demand curves for all DAC destinations
  data.plot.demand <- data.row %>%
    unnest(demand) %>%
    select(year, demand, dac_target_base) %>%  
    group_by(year) %>%
    reframe(demand_mean = mean(demand))  # Using reframe instead of summarise
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4050
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }

  # Create plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )
 
 
   # Optional zoom panel
   if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, t.max),
        ylim = c(0, max(data.plot.demand$demand_mean)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
    p.plot <- p.facet 
  
  return(p.plot)
}

# Adaptation of the plotProbabilisticFeasibilitySpace_with_base_median function
plotProbabilisticFeasibilitySpace_with_base_median <- function(data.row,
                                                              dac_target_base,
                                                              dac_target_policy,
                                                              colour_index,
                                                              plot.marginal = T,
                                                              marginal.year,
                                                              title,
                                                              ci.80 = F,
                                                              slices = 1000,
                                                              random.paths = 10,
                                                              base_case_median, 
                                                              show_LNG_wind_medians = TRUE, 
                                                              LNG_data_stat = NULL,  
                                                              wind_data_stat = NULL, 
                                                              text_offset = 0.1, 
                                                              text_offset_LNG = -0.1, 
                                                              text_offset_wind = 0.2,
                                                              zoom.panel = F,
                                                              round_to_tens = TRUE) {  
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)

  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3), 
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  
                   "0.5" = darken(base_color, 0.3),  
                   "0.05" = base_color)  
  }
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Receive demand
  data.plot.demand <- data.plot %>%
    filter(sample == 1)
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4600

    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Plot erstellen
  p.facet <- ggplot() +
    geom_raster(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density),
      interpolate = TRUE
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    # Median A) Base Case hinzufgen
    geom_line(
      data = base_case_median,
      aes(x = year, y = x),
      linetype = "dotted",  
      color = "#E64B35FF",  
      linewidth = 0.8  
    ) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
    plot.title = element_text(face = "bold", size = font.size)
  )
 
  # Show LNG/Wind medians only if activated
  if (show_LNG_wind_medians) {
    # Add LNG median 
    p.facet <- p.facet + 
      geom_line(
        data = LNG_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "#00A087FF",  
        linewidth = 0.8
      )
    # Add wind energy median 
    p.facet <- p.facet + 
      geom_line(
        data = wind_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "blue",  
        linewidth = 0.8
      )
  }
  
  # Optional zoom panel
  if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, 2030),
        ylim = c(0, data.plot.targets %>% filter(year == 2030) %>% pull(value)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
  
  p.plot <- p.facet 
  
  # Calculation of the percentage deviation between the median of the base case 
  #and the median of the current curve
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- data.stat %>% filter(q == 0.5, year == marginal.year) %>% pull(x)
  percentage_difference <- ((current_median_value - base_median_value) / 
                              base_median_value) * 100

  # Apply rounding to 10s or 1s depending on the parameter
  round_digits <- ifelse(round_to_tens, -1, 0)

  # Add text to display the percentage deviation
p.plot <- p.plot +
  annotate("text", x = max(data.stat$year) + 1, 
           y = min(current_median_value + text_offset * current_median_value, 5000), 
           label = paste0("~ ", format(round(percentage_difference, round_digits), 
                                       nsmall = 0), " % "),
           hjust = 1, size = 3, color = "#E64B35FF")

# Calculation and annotation for LNG median deviation
if (show_LNG_wind_medians && !is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == marginal.year) %>% pull(x)
  LNG_percentage_difference <- ((LNG_median_value - base_median_value) / 
                                  base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5400), 
             label = paste0("~ ", format(round(LNG_percentage_difference, round_digits), 
                                         nsmall = 0), " %  LNG"),  # Dynamische Rundung
             hjust = 1, size = 3, color = "#00A087FF")
}

# Calculation and annotation for wind energy median deviation
if (show_LNG_wind_medians && !is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == marginal.year) %>% pull(x)
  wind_percentage_difference <- ((wind_median_value - base_median_value) / 
                                   base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5800), 
             label = paste0("~ ", format(round(wind_percentage_difference, round_digits), 
                                         nsmall = 0), " %  Wind"), 
             hjust = 1, size = 3, color = "blue")
}
  
  # Legend for all lines
  if (show_LNG_wind_medians) {
    p.plot <- p.plot +
      scale_color_manual(
        values = c(
          "Base case median" = "#E64B35FF",  
          "LNG median" = "#00A087FF",           
          "Wind median" = "blue"             
        ),
        labels = c(
          "Base case median" = "Base case median",
          "LNG median" = "LNG median",
          "Wind median" = "Wind median"
        ),
        name = "Medians"
      ) +
      guides(
        color = guide_legend(
          override.aes = list(
            linetype = c("dotted", "dashed", "dashed"), 
            color = c("#E64B35FF", "#00A087FF", "blue")
          ),
          order = 5
        )
      )
  }
  
  return(p.plot)
}


# A) Base case
p_base_case <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 5,
  title = "Base case"
)

# Median of the base case
base_case_median <- data.results %>%
  filter(region == "Global", anticipation == 5) %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results) %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  # Calculate median (50% quantile)

base_case_median <- as.data.frame(base_case_median)

# B) Enhanced policy case
p_policy_case_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.policy %>%
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 2,
  marginal.year = 2045,
  title = "Enhanced policy case",
  base_case_median = base_case_median,
  show_LNG_wind_medians = TRUE,  # Show LNG/Wind median
  LNG_data_stat = LNG_data_stat,  # LNG median data
  wind_data_stat = wind_data_stat,  # Wind median data
  text_offset = 30, 
  text_offset_LNG = 0.7, 
  text_offset_wind = 0.9 
)

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 10
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>%
    filter(region == "Global", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 65,
  round_to_tens = FALSE  
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>%
    filter(region == "Global", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset =65,
  round_to_tens = FALSE  
)


# Adjustment of the y-axis

# A) Global Base Case
p_base_case <- p_base_case + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# B) Global Policy Case
p_policy_case_with_median <- p_policy_case_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )


# i) Policy Push: Short-term Capacity
p_policy_push_with_median <- p_policy_push_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# ii) Demand Pull: Anticipation
p_demand_pull_anticipation_with_median <- p_demand_pull_anticipation_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# iii) Demand Pull: Long-term Market Growth
p_demand_pull_ltm_with_median <- p_demand_pull_ltm_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# Merging the plots into the layout

# Upper part with A) and B)
upper_plot <- plot_grid(
  p_base_case, p_policy_case_with_median,
  ncol = 2, nrow = 1,
  labels = c("A", "B"),
  label_size = 10,
  rel_widths = c(1, 1)  
)

# Title for the lower part C)
title_lower_plots <- ggdraw() +
  draw_label(
    "C       Policy levers",  # Title for the lower plots
    fontface = 'bold', 
    size = 10,
    hjust = 0,  # Left-align text
    x = 0,   # Indentation of the title
    y = 0.7  # Vertical position of the title
  )

# Lower part with the three smaller plots (i to iii) with inserted median
lower_plot <- plot_grid(
  p_policy_push_with_median, p_demand_pull_anticipation_with_median, p_demand_pull_ltm_with_median,
  ncol = 3, nrow = 1,
  labels = c("i", "ii", "iii"),
  label_size = 10
)

# Final plot with a main centered title
title <- ggdraw() + 
  draw_label(
    "Global DAC Capacity in 2100",
    fontface = 'bold',
    size = 12,  # Adjust size as needed
    hjust = 0.5,  # Centered
    vjust = 0.1 # Adjust to increase spacing below the title
  )

# Combine everything into the final plot with adjusted spacing
final_plot <- plot_grid(
  title,
  upper_plot,
  title_lower_plots,  
  lower_plot, 
  ncol = 1, nrow = 4,
  rel_heights = c(0.1, 2, 0.1, 1)  # Increase height for the title
)

print(final_plot)

# Save the final plot with adjusted dimensions
ggsave(paste0(path.output, "SI_VISUAL_7_Probabilistic_Feasibility_Space_AMMONIA_Global.pdf"),
       plot = final_plot,
      width = 30, height = 33, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_VISUAL_7_Probabilistic_Feasibility_Space_AMMONIA_Global.png"),
       plot = final_plot,
      width = 30, height = 33, units = "cm", bg = "white")

```

#SI_Visual 8: A) Base case versus B) Enhanced policy case ^and C) the individual policy levers (Global)

```{r}
# Colours out of pal_npg-Palette
colours <- pal_npg("nrc")(10) 

# Loading CSV data
LNG_data <- read.csv(here("02_output_plots_new",                     "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG_2100.csv"))
wind_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind_2100.csv"))

# Calculating median of LNG data
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Calculating median of wind energy data
wind_data_stat <- wind_data %>%
  group_by(year) %>%
  reframe(x = quantile(forecast, 0.5))  

# Function for creating plots with consistent colouring
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour_index,
                                              title,
                                              dac_target_base,
                                              ci.80 = F,  # 80% Confidence interval
                                              slices = 500,
                                              random.paths = 10,
                                              zoom.panel = F) { 
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  }
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }

  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))

  # Receive demand curves for all DAC destinations
  data.plot.demand <- data.row %>%
    unnest(demand) %>%
    select(year, demand, dac_target_base) %>%  
    group_by(year) %>%
    reframe(demand_mean = mean(demand))  # Using reframe instead of summarise
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4200
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }

  # Create plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )
 
 
   # Optional zoom panel
   if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, t.max),
        ylim = c(0, max(data.plot.demand$demand_mean)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
    p.plot <- p.facet 
  
  return(p.plot)
}

# Adaptation of the plotProbabilisticFeasibilitySpace_with_base_median function
plotProbabilisticFeasibilitySpace_with_base_median <- function(data.row,
                                                              dac_target_base,
                                                              dac_target_policy,
                                                              colour_index,
                                                              plot.marginal = T,
                                                              marginal.year,
                                                              title,
                                                              ci.80 = F,
                                                              slices = 500,
                                                              random.paths = 10,
                                                              base_case_median,  
                                                              show_LNG_wind_medians = TRUE, 
                                                              LNG_data_stat = NULL,  
                                                              wind_data_stat = NULL,  
                                                              text_offset = 0.1, 
                                                              text_offset_LNG = -0.1, 
                                                              text_offset_wind = 0.2,
                                                              zoom.panel = F,
                                                              round_to_tens = TRUE) {  
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)

  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3), 
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  
                   "0.5" = darken(base_color, 0.3),  
                   "0.05" = base_color)  
  }
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%  
    mutate(q = as.factor(q))
  
  # Receive demand
  data.plot.demand <- data.plot %>%
    filter(sample == 1)
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4700
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Plot erstellen
  p.facet <- ggplot() +
    geom_raster(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density),
      interpolate = TRUE
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    # Median A) Base Case hinzufgen
    geom_line(
      data = base_case_median,
      aes(x = year, y = x),
      linetype = "dotted",  
      color = "#E64B35FF",  
      linewidth = 0.8  
    ) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
    plot.title = element_text(face = "bold", size = font.size)
  )
 
  # Show LNG/Wind medians only if activated
  if (show_LNG_wind_medians) {
    # Add LNG median 
    p.facet <- p.facet + 
      geom_line(
        data = LNG_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "#00A087FF",  
        linewidth = 0.8
      )
    # Add wind energy median 
    p.facet <- p.facet + 
      geom_line(
        data = wind_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "blue",  
        linewidth = 0.8
      )
  }
  
  # Optional zoom panel
  if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, 2030),
        ylim = c(0, data.plot.targets %>% filter(year == 2030) %>% pull(value)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
  
  p.plot <- p.facet 
  
  # Calculation of the percentage deviation between the median of the base case 
  #and the median of the current curve
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- data.stat %>% filter(q == 0.5, year == marginal.year) %>% pull(x)
  percentage_difference <- ((current_median_value - base_median_value) / 
                              base_median_value) * 100

  # Apply rounding to 10s or 1s depending on the parameter
  round_digits <- ifelse(round_to_tens, -1, 0)

  # Add text to display the percentage deviation
p.plot <- p.plot +
  annotate("text", x = max(data.stat$year) + 1, 
           y = min(current_median_value + text_offset * current_median_value, 5000), 
           label = paste0("~ ", format(round(percentage_difference, round_digits), 
                                       nsmall = 0), " % "),
           hjust = 1, size = 3, color = "#E64B35FF")

# Calculation and annotation for LNG median deviation
if (show_LNG_wind_medians && !is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == marginal.year) %>% pull(x)
  LNG_percentage_difference <- ((LNG_median_value - base_median_value) / 
                                  base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5400), 
             label = paste0("~ ", format(round(LNG_percentage_difference, round_digits), 
                                         nsmall = 0), " %  LNG"), 
             hjust = 1, size = 3, color = "#00A087FF")
}

# Calculation and annotation for wind energy median deviation
if (show_LNG_wind_medians && !is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == marginal.year) %>% pull(x)
  wind_percentage_difference <- ((wind_median_value - base_median_value) / 
                                   base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5800), 
             label = paste0("~ ", format(round(wind_percentage_difference, round_digits), 
                                         nsmall = 0), " %  Wind"), 
             hjust = 1, size = 3, color = "blue")
}
  
  # Legend for all lines
  if (show_LNG_wind_medians) {
    p.plot <- p.plot +
      scale_color_manual(
        values = c(
          "Base case median" = "#E64B35FF",  
          "LNG median" = "#00A087FF",           
          "Wind median" = "blue"             
        ),
        labels = c(
          "Base case median" = "Base case median",
          "LNG median" = "LNG median",
          "Wind median" = "Wind median"
        ),
        name = "Medians"
      ) +
      guides(
        color = guide_legend(
          override.aes = list(
            linetype = c("dotted", "dashed", "dashed"), 
            color = c("#E64B35FF", "#00A087FF", "blue") 
          ),
          order = 5
        )
      )
  }
  
  return(p.plot)
}


# A) Base case
p_base_case <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "Europe", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 5,
  title = "Base case"
)

# Median of the base case
base_case_median <- data.results %>%
  filter(region == "Europe", anticipation == 5) %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results) %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  # Calculate median (50% quantile)

base_case_median <- as.data.frame(base_case_median)

# B) Enhanced policy case
p_policy_case_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.policy %>%
    filter(region == "Europe", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 2,
  marginal.year = 2045,
  title = "Enhanced policy case",
  base_case_median = base_case_median,
  show_LNG_wind_medians = TRUE,  # Show LNG/Wind median
  LNG_data_stat = LNG_data_stat,  # LNG median data
  wind_data_stat = wind_data_stat,  # Wind median data
  text_offset = 50, 
  text_offset_LNG = 0.7, 
  text_offset_wind = 0.9 
)

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>%
    filter(region == "Europe", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 10
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>%
    filter(region == "Europe", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 85,
  round_to_tens = FALSE  
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>%
    filter(region == "Europe", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 85,
  round_to_tens = FALSE  
)


# Adjustment of the y-axis

# A) Europe Base Case
p_base_case <- p_base_case + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# B) Europe Policy Case
p_policy_case_with_median <- p_policy_case_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )


# i) Policy Push: Short-term Capacity
p_policy_push_with_median <- p_policy_push_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# ii) Demand Pull: Anticipation
p_demand_pull_anticipation_with_median <- p_demand_pull_anticipation_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# iii) Demand Pull: Long-term Market Growth
p_demand_pull_ltm_with_median <- p_demand_pull_ltm_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# Merging the plots into the layout

# Upper part with A) and B)
upper_plot <- plot_grid(
  p_base_case, p_policy_case_with_median,
  ncol = 2, nrow = 1,
  labels = c("A", "B"),
  label_size = 10,
  rel_widths = c(1, 1)  
)

# Title for the lower part C) Policy levers
title_lower_plots <- ggdraw() +
  draw_label(
    "C        Policy levers",  # Title for the lower plots
    fontface = 'bold', 
    size = 10,
    hjust = 0,  # Left-align text
    x = 0,   # Indentation of the title
    y = 0.7  # Vertical position of the title
  )

# Lower part with the three smaller plots (i to iii) with inserted median
lower_plot <- plot_grid(
  p_policy_push_with_median, p_demand_pull_anticipation_with_median,
  p_demand_pull_ltm_with_median,
  ncol = 3, nrow = 1,
  labels = c("i", "ii", "iii"),
  label_size = 10
)

# Final plot with a main centered title
title <- ggdraw() + 
  draw_label(
    "Europe DAC Capacity in 2100",
    fontface = 'bold',
    size = 12,  # Adjust size as needed
    hjust = 0.5,  # Centered
    vjust = 0.1 # Adjust to increase spacing below the title
  )

# Combine everything into the final plot with adjusted spacing
final_plot <- plot_grid(
  title,
  upper_plot,
  title_lower_plots,  
  lower_plot, 
  ncol = 1, nrow = 4,
  rel_heights = c(0.1, 2, 0.1, 1)  # Increase height for the title
)

print(final_plot)

# Save the final plot with adjusted dimensions
ggsave(paste0(path.output, "SI_VISUAL_8_Probabilistic_Feasibility_Space_AMMONIA_Europe.pdf"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
ggsave(paste0(path.output, "SI_VISUAL_8_Probabilistic_Feasibility_Space_AMMONIA_Europe.png"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")

```

#SI_Visual 9: A) Base case versus B) Enhanced policy case and C) the individual policy levers (Global)

```{r}
# Colours out of pal_npg-Palette
colours <- pal_npg("nrc")(10) 

# Loading CSV data
LNG_data <- read.csv(here("02_output_plots_new",                       "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_LNG_2100.csv"))
wind_data <- read.csv(here("02_output_plots_new", "SUBVISUAL_B_Probabilistic_Feasibility_Space_TechnologyPolicy_Wind_2100.csv"))

# Calculating median of LNG data
LNG_data_stat <- LNG_data %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  

# Calculating median of wind energy data
wind_data_stat <- wind_data %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))

# Function for creating plots with consistent colouring
plotProbabilisticFeasibilitySpace <- function(data.row,
                                              colour_index,
                                              title,
                                              dac_target_base,
                                              ci.80 = F,  # 80% Confidence interval
                                              slices = 500,
                                              random.paths = 10,
                                              zoom.panel = F) { 
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)
  
  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  # Lightest shade
                   "0.5" = darken(base_color, 0.3),  # Darkest shade for the median
                   "0.05" = base_color)  # Medium shading for the 5% percentile
  }
  
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }

  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))

  # Receive demand curves for all DAC destinations
  data.plot.demand <- data.row %>%
    unnest(demand) %>%
    select(year, demand, dac_target_base) %>%  
    group_by(year) %>%
    reframe(demand_mean = mean(demand))  # Using reframe instead of summarise
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4500
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }

  # Create plot
  p.facet <- ggplot() +
    geom_tile(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density)
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA), 
    plot.title = element_text(face = "bold", size = font.size)
  )
 
 
   # Optional zoom panel
   if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, t.max),
        ylim = c(0, max(data.plot.demand$demand_mean)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
    p.plot <- p.facet 
  
  return(p.plot)
}

# Adaptation of the plotProbabilisticFeasibilitySpace_with_base_median function
plotProbabilisticFeasibilitySpace_with_base_median <- function(data.row,
                                                              dac_target_base,
                                                              dac_target_policy,
                                                              colour_index,
                                                              plot.marginal = T,
                                                              marginal.year,
                                                              title,
                                                              ci.80 = F,
                                                              slices = 500,
                                                              random.paths = 10,
                                                              base_case_median, 
                                                              show_LNG_wind_medians = TRUE, 
                                                              LNG_data_stat = NULL,  
                                                              wind_data_stat = NULL,  
                                                              text_offset = 0.1, 
                                                              text_offset_LNG = -0.1, 
                                                              text_offset_wind = 0.2,
                                                              zoom.panel = F,
                                                              round_to_tens = TRUE) {  
  
  # Prepare data
  data.plot <- data.row %>%
    unnest(sensitivities) %>%
    select(!demand) %>%
    unnest(results)

  # Select base colour for the plot
  base_color <- colours[colour_index]
  
  # Calculate median and percentiles
  if (ci.80 == T) {
    quantiles <- c(0.95, 0.9, 0.5, 0.1, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3), 
                   "0.9" = lighten(base_color, 0.2),
                   "0.5" = darken(base_color, 0.3),  
                   "0.1" = darken(base_color, 0.15),
                   "0.05" = base_color)  
  } else {
    quantiles <- c(0.95, 0.5, 0.05)
    col.quant <- c("0.95" = lighten(base_color, 0.3),  
                   "0.5" = darken(base_color, 0.3),  
                   "0.05" = base_color)  
  }
  quibble <- function(x, q = quantiles) {
    tibble(x = quantile(x, q), q = q)
  }
  data.stat <- data.plot %>%
    group_by(year) %>%
    reframe(quibble(forecast)) %>%
    mutate(q = as.factor(q))
  
  # Receive demand
  data.plot.demand <- data.plot %>%
    filter(sample == 1)
  
  # Select random paths
  data.plot.random <- data.plot %>%
    filter(sample %in% sample(1:max(data.plot$sample), random.paths))
  
  # Calculate density of scenarios for each year and save in grid
  data.raster <- NULL
  for (y in unique(data.plot$year)) {
    subset <- data.plot %>%
      filter(year == y) %>%
      pull(forecast)
    dens <- density(
      subset,
      n = slices,
      na.rm = T,
      from = 0,
      to = 4750
    )
    dens$y <- dens$y / max(dens$y)
    temp <- tibble(year = y,
                   forecast = dens$x,
                   density = dens$y)
    data.raster <- bind_rows(data.raster, temp)
  }
  
  # Plot erstellen
  p.facet <- ggplot() +
    geom_raster(
      data = data.raster,
      mapping = aes(x = year, y = forecast, fill = density),
      interpolate = TRUE
    ) +
    scale_fill_gradient(name = "Probability density\n(normalised)", low = "white", 
                        high = base_color) +
    geom_line(
      data = data.plot.random,
      mapping = aes(
        x = year,
        y = forecast,
        group = sample,
        color = "Example path"
      ),
      lwd = 0.5,
      alpha = 0.5
    ) +
    scale_color_manual(
      values = c("Example path" = "grey"),
      name = NULL,
      guide = guide_legend(order = 3)
    ) +
    new_scale_color() +
    geom_line(
      data = data.stat,
      mapping = aes(x = year, y = x, color = q),
      linewidth = 1
    ) +
    scale_color_manual(values = col.quant,
                       name = "Percentiles",
                       labels = c("0.95" = "95 %",
                                  "0.9" = "90 %",
                                  "0.5" = "50 % (Median)",
                                  "0.1" = "10 %",
                                  "0.05" = "5 %"),
                       guide = guide_legend(order = 4)) +
    new_scale_color() +
    # Median A) Base Case hinzufgen
    geom_line(
      data = base_case_median,
      aes(x = year, y = x),
      linetype = "dotted",  
      color = "#E64B35FF",  
      linewidth = 0.8  
    ) +
  xlab("year") +
  scale_x_continuous(
    breaks = seq(2030, 2100, by = 10)
  ) +
  ylab(expression("DAC Capacity [GtCO"[2]*"/a]")) +
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500)
  ) +
    ggtitle(title) +
    theme(
    legend.position = c(0.1, 0.9),  
    legend.justification = c(0, 1),  
    legend.background = element_rect(fill = alpha("white", 0.7), color = NA),  
    plot.title = element_text(face = "bold", size = font.size)
  )
 
  # Show LNG/Wind medians only if activated
  if (show_LNG_wind_medians) {
    # Add LNG median 
    p.facet <- p.facet + 
      geom_line(
        data = LNG_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "#00A087FF",  
        linewidth = 0.8
      )
    # Add wind energy median 
    p.facet <- p.facet + 
      geom_line(
        data = wind_data_stat,
        aes(x = year, y = x),
        linetype = "dashed",  
        color = "blue",  
        linewidth = 0.8
      )
  }
  
  # Optional zoom panel
  if (zoom.panel == T) {
    p.facet <- p.facet +
      facet_zoom(
        xlim = c(t.split, 2030),
        ylim = c(0, data.plot.targets %>% filter(year == 2030) %>% pull(value)),
        horizontal = FALSE,
        zoom.size = 0.5,
        show.area = FALSE
     )
  }
  
  p.plot <- p.facet 
  
  # Calculation of the percentage deviation between the median of 
  #the base case and the median of the current curve
  base_median_value <- base_case_median %>% filter(year == marginal.year) %>% pull(x)
  current_median_value <- data.stat %>% filter(q == 0.5, year == marginal.year) %>% 
    pull(x)
  percentage_difference <- ((current_median_value - base_median_value) / 
                              base_median_value) * 100

  # Apply rounding to 10s or 1s depending on the parameter
  round_digits <- ifelse(round_to_tens, -1, 0)

  # Add text to display the percentage deviation
p.plot <- p.plot +
  annotate("text", x = max(data.stat$year) + 1, 
           y = min(current_median_value + text_offset * current_median_value, 5000), 
           label = paste0("~ ", format(round(percentage_difference, round_digits), 
                                       nsmall = 0), " % "),  # Dynamische Rundung
           hjust = 1, size = 3, color = "#E64B35FF")

# Calculation and annotation for LNG median deviation
if (show_LNG_wind_medians && !is.null(LNG_data_stat)) {
  LNG_median_value <- LNG_data_stat %>% filter(year == marginal.year) %>% pull(x)
  LNG_percentage_difference <- ((LNG_median_value - base_median_value) / 
                                  base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5400), 
             label = paste0("~ ", format(round(LNG_percentage_difference, round_digits), 
                                         nsmall = 0), " %  LNG"),
             hjust = 1, size = 3, color = "#00A087FF")
}

# Calculation and annotation for wind energy median deviation
if (show_LNG_wind_medians && !is.null(wind_data_stat)) {
  wind_median_value <- wind_data_stat %>% filter(year == marginal.year) %>% pull(x)
  wind_percentage_difference <- ((wind_median_value - base_median_value) / 
                                   base_median_value) * 100
  
  p.plot <- p.plot +
    annotate("text", x = max(data.stat$year) + 1, 
             y = min(current_median_value + text_offset * current_median_value, 5800), 
             label = paste0("~ ", format(round(wind_percentage_difference, round_digits), 
                                         nsmall = 0), " %  Wind"), 
             hjust = 1, size = 3, color = "blue")
}
  
  # Legend for all lines
  if (show_LNG_wind_medians) {
    p.plot <- p.plot +
      scale_color_manual(
        values = c(
          "Base case median" = "#E64B35FF",  
          "LNG median" = "#00A087FF",           
          "Wind median" = "blue"             
        ),
        labels = c(
          "Base case median" = "Base case median",
          "LNG median" = "LNG median",
          "Wind median" = "Wind median"
        ),
        name = "Medians"
      ) +
      guides(
        color = guide_legend(
          override.aes = list(
            linetype = c("dotted", "dashed", "dashed"), 
            color = c("#E64B35FF", "#00A087FF", "blue") 
          ),
          order = 5
        )
      )
  }
  
  return(p.plot)
}

# A) Base case
p_base_case <- plotProbabilisticFeasibilitySpace(
  data.row = data.results %>%
    filter(region == "North America", anticipation == 5),
  dac_target_base = dac_target_base,
  colour_index = 5,
  title = "Base case"
)

# Median of the base case
base_case_median <- data.results %>%
  filter(region == "North America", anticipation == 5) %>%
  unnest(sensitivities) %>%
  select(!demand) %>%
  unnest(results) %>%
  group_by(year) %>%
  summarise(x = quantile(forecast, 0.5))  # Calculate median (50% quantile)

base_case_median <- as.data.frame(base_case_median)

# B) Enhanced policy case
p_policy_case_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.policy %>%
    filter(region == "North America", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 2,
  marginal.year = 2045,
  title = "Enhanced policy case",
  base_case_median = base_case_median,
  show_LNG_wind_medians = TRUE,  # Show LNG/Wind median
  LNG_data_stat = LNG_data_stat,  # LNG median data
  wind_data_stat = wind_data_stat,  # Wind median data
  text_offset = 30, 
  text_offset_LNG = 0.7, 
  text_offset_wind = 0.9 
)

# i) Policy push fostering short-term DAC capacity (in 2030)
p_policy_push_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.capacity %>%
    filter(region == "North America", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "policy push fostering short-term DAC\n capacity (in 2030)",
  base_case_median = base_case_median,
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 15
)

# ii) Creating credibility in long-term DAC requirements
p_demand_pull_anticipation_with_median <- 
  plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.anticipation %>%
    filter(region == "North America", anticipation == 15),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "creating credibility in long-term\n DAC requirements",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 90,
  round_to_tens = FALSE  
)

# iii) Securing minimum long-term DAC demand
p_demand_pull_ltm_with_median <- plotProbabilisticFeasibilitySpace_with_base_median(
  data.row = data.results.longterm %>%
    filter(region == "North America", anticipation == 5),
  dac_target_base = dac_target_base,
  dac_target_policy = dac_target_policy,
  colour_index = 6,
  marginal.year = 2045,
  title = "securing minimum long-term DAC demand",
  base_case_median = base_case_median, 
  show_LNG_wind_medians = FALSE,  # Do not show additional medians
  text_offset = 95,
  round_to_tens = FALSE  
)


# Adjustment of the y-axis

# A) North America Base Case
p_base_case <- p_base_case + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# B) North America Policy Case
p_policy_case_with_median <- p_policy_case_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )


# i) Policy Push: Short-term Capacity
p_policy_push_with_median <- p_policy_push_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# ii) Demand Pull: Anticipation
p_demand_pull_anticipation_with_median <- p_demand_pull_anticipation_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# iii) Demand Pull: Long-term Market Growth
p_demand_pull_ltm_with_median <- p_demand_pull_ltm_with_median + 
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-3),
    expand = expansion(mult = c(0.01, 0.05)),
    limits = c(0, 6000),
    breaks = seq(0, 6000, by = 500) 
  )

# Merging the plots into the layout

# Upper part with A) and B)
upper_plot <- plot_grid(
  p_base_case, p_policy_case_with_median,
  ncol = 2, nrow = 1,
  labels = c("A", "B"),
  label_size = 10,
  rel_widths = c(1, 1)  
)

# Title for the lower part C) Policy levers
title_lower_plots <- ggdraw() +
  draw_label(
    "C        Policy levers",  # Title for the lower plots
    fontface = 'bold', 
    size = 10,
    hjust = 0,  # Left-align text
    x = 0,   # Indentation of the title
    y = 0.7  # Vertical position of the title
  )

# Lower part with the three smaller plots (i to iii) with inserted median
lower_plot <- plot_grid(
  p_policy_push_with_median, p_demand_pull_anticipation_with_median,
  p_demand_pull_ltm_with_median,
  ncol = 3, nrow = 1,
  labels = c("i", "ii", "iii"),
  label_size = 10
)

# Final plot with a main centered title
title <- ggdraw() + 
  draw_label(
    "North America DAC Capacity in 2100",
    fontface = 'bold',
    size = 12,  # Adjust size as needed
    hjust = 0.5,  # Centered
    vjust = 0.1 # Adjust to increase spacing below the title
  )

# Combine everything into the final plot with adjusted spacing
final_plot <- plot_grid(
  title,
  upper_plot,
  title_lower_plots,  
  lower_plot, 
  ncol = 1, nrow = 4,
  rel_heights = c(0.1, 2, 0.1, 1)  # Increase height for the title
)

print(final_plot)

# Save the final plot with adjusted dimensions
ggsave(paste0(path.output,
"SI_VISUAL_9_Probabilistic_Feasibility_Space_AMMONIA_NorthAmerica.pdf"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
ggsave(paste0(path.output,
"SI_VISUAL_9_Probabilistic_Feasibility_Space_AMMONIA_NorthAmerica.png"),
       plot = final_plot,
       width = 30, height = 32, units = "cm", bg = "white")
```
